based on spec.md, derive a formal spec in Verus in src/{spec.rs, model.rs} about the elf dynamic loader that can be used for a real implementation. use verus/examples to guide you on how to write verus code. For the spec, the input should start with a sequence of objects, where the objects consist of their name and sequence of bytes. the output should be the entry pc, a list of initializer to call, and a sequence of plans about mmap, where each of them consist of a starting address, the bytes to be mapped and the protection flags. it would be very helpful for you to organize the loader into different stages, and have spec and struct about each stage. for example, we could have a parse stage, a dependency discovery stage, a symbol resolution stage, a relocation stage, etc. just to give some examples. make sure that you have some implementation in mind while you are writing down the spec. don't make it hard to implement or verify. do not miss any detail about the spec that is required to implemnt a loader. do not cheat and read git history.  And since you are taking the bytes as input, you will also need to model the constants specified by the ELF spec. First write down design.md and todo.md. 

Implement the spec in spec.rs and model.rs. Make sure that the implementation matches the spec. The only thing not verified is the loading of inputs, and the runtime code given LoaderOutput. Do not implement everything in one file. You can assume that the only directory to search for .so files is /lib. Do not take shortcuts on proving the implementation matches the spec. Make sure everything is proven. The runtime needs to implement the actual logic to mmap the segments and call the initializers, setup stack and call the entry point.
