---
title: "System V ABI AMD64 Architecture Processor Supplement (Draft 0.95) — Markdown conversion"
source: "x86_64.pdf"
generated: "2026-02-21T14:42:33Z"
---

> Converted from the original PDF. Formatting (tables/figures) is best-effort.



---

## Page 1: System V Application Binary Interface

System V Application Binary Interface
AMD64 Architecture Processor Supplement
Draft Version 0.95
Edited by
Jan Hubicˇka1, Andreas Jaeger2, Mark Mitchell3
January 24, 2005
1jh@suse.cz
2aj@suse.de
3mark@codesourcery.com
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 2: Contents

### Contents
### 1 Introduction 8
### 1.1 DifferencesfromtheIntel386ABI . . . . . . . . . . . . . . . . . 8
### 2 SoftwareInstallation 10
### 3 LowLevelSystemInformation 11
### 3.1 MachineInterface . . . . . . . . . . . . . . . . . . . . . . . . . . 11
### 3.1.1 ProcessorArchitecture . . . . . . . . . . . . . . . . . . . 11
### 3.1.2 DataRepresentation . . . . . . . . . . . . . . . . . . . . 11
### 3.2 FunctionCallingSequence . . . . . . . . . . . . . . . . . . . . . 14
### 3.2.1 RegistersandtheStackFrame . . . . . . . . . . . . . . . 14
### 3.2.2 TheStackFrame . . . . . . . . . . . . . . . . . . . . . . 15
### 3.2.3 ParameterPassing . . . . . . . . . . . . . . . . . . . . . 16
### 3.3 OperatingSystemInterface . . . . . . . . . . . . . . . . . . . . . 23
### 3.3.1 ExceptionInterface . . . . . . . . . . . . . . . . . . . . . 23
### 3.3.2 VirtualAddressSpace . . . . . . . . . . . . . . . . . . . 23
### 3.3.3 PageSize . . . . . . . . . . . . . . . . . . . . . . . . . . 23
### 3.3.4 VirtualAddressAssignments . . . . . . . . . . . . . . . . 23
### 3.4 ProcessInitialization . . . . . . . . . . . . . . . . . . . . . . . . 26
### 3.4.1 InitialStackandRegisterState . . . . . . . . . . . . . . . 26
### 3.4.2 AuxiliaryVector . . . . . . . . . . . . . . . . . . . . . . 29
### 3.5 CodingExamples . . . . . . . . . . . . . . . . . . . . . . . . . . 31
### 3.5.1 ArchitecturalConstraints . . . . . . . . . . . . . . . . . . 32
### 3.5.2 Conventions . . . . . . . . . . . . . . . . . . . . . . . . 34
### 3.5.3 Position-IndependentFunctionPrologue . . . . . . . . . . 35
### 3.5.4 DataObjects . . . . . . . . . . . . . . . . . . . . . . . . 35
### 3.5.5 FunctionCalls . . . . . . . . . . . . . . . . . . . . . . . 44
### 3.5.6 Branching . . . . . . . . . . . . . . . . . . . . . . . . . . 46
1
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 3: 3.5.7 VariableArgumentLists . . . . . . . . . . . . . . . . . . 49

### 3.5.7 VariableArgumentLists . . . . . . . . . . . . . . . . . . 49
### 3.6 DWARFDefinition . . . . . . . . . . . . . . . . . . . . . . . . . 54
### 3.6.1 DWARFReleaseNumber . . . . . . . . . . . . . . . . . 54
### 3.6.2 DWARFRegisterNumberMapping . . . . . . . . . . . . 54
### 3.7 StackUnwindAlgorithm . . . . . . . . . . . . . . . . . . . . . . 54
### 4 ObjectFiles 58
### 4.1 ELFHeader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
### 4.1.1 MachineInformation . . . . . . . . . . . . . . . . . . . . 58
### 4.2 Sections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
### 4.2.1 SectionFlags . . . . . . . . . . . . . . . . . . . . . . . . 59
### 4.2.2 Sectiontypes . . . . . . . . . . . . . . . . . . . . . . . . 59
### 4.2.3 Specialsections . . . . . . . . . . . . . . . . . . . . . . . 60
### 4.2.4 EH_FRAMEsections . . . . . . . . . . . . . . . . . . . 61
### 4.3 SymbolTable . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
### 4.4 Relocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
### 4.4.1 RelocationTypes . . . . . . . . . . . . . . . . . . . . . . 65
### 4.4.2 LargeModels . . . . . . . . . . . . . . . . . . . . . . . . 69
### 5 ProgramLoadingandDynamicLinking 71
### 5.1 ProgramLoading . . . . . . . . . . . . . . . . . . . . . . . . . . 71
### 5.1.1 Programheader . . . . . . . . . . . . . . . . . . . . . . . 72
### 5.2 DynamicLinking . . . . . . . . . . . . . . . . . . . . . . . . . . 72
### 5.2.1 ProgramInterpreter . . . . . . . . . . . . . . . . . . . . . 78
### 5.2.2 InitializationandTerminationFunctions . . . . . . . . . . 78
### 6 Libraries 79
### 6.1 CLibrary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
### 6.1.1 GlobalDataSymbols . . . . . . . . . . . . . . . . . . . . 79
### 6.1.2 FloatingPointEnvironmentFunctions . . . . . . . . . . . 79
### 6.2 UnwindLibraryInterface . . . . . . . . . . . . . . . . . . . . . . 80
### 6.2.1 ExceptionHandlerFramework . . . . . . . . . . . . . . . 81
### 6.2.2 DataStructures . . . . . . . . . . . . . . . . . . . . . . . 83
### 6.2.3 ThrowinganException . . . . . . . . . . . . . . . . . . . 85
### 6.2.4 ExceptionObjectManagement . . . . . . . . . . . . . . . 88
### 6.2.5 ContextManagement . . . . . . . . . . . . . . . . . . . . 88
### 6.2.6 PersonalityRoutine . . . . . . . . . . . . . . . . . . . . . 91
### 6.3 UnwindingThroughAssemblerCode . . . . . . . . . . . . . . . 95
2
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 4: 7 DevelopmentEnvironment 98

### 7 DevelopmentEnvironment 98
### 8 ExecutionEnvironment 99
### 9 Conventions 100
### 9.1 GOTpointerandIPrelativeaddressing . . . . . . . . . . . . . . . 100
### 9.2 C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
### 9.3 Fortran . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
### 9.3.1 RepresentationofFortranTypes . . . . . . . . . . . . . . 101
### 9.3.2 ArgumentPassing . . . . . . . . . . . . . . . . . . . . . 102
A LinuxConventions 104
A.1 Executionof32-bitPrograms . . . . . . . . . . . . . . . . . . . . 104
A.2 AMD64LinuxKernelConventions . . . . . . . . . . . . . . . . . 104
A.2.1 CallingConventions . . . . . . . . . . . . . . . . . . . . 104
A.2.2 StackLayout . . . . . . . . . . . . . . . . . . . . . . . . 105
A.2.3 RequiredProcessorFeatures . . . . . . . . . . . . . . . . 105
A.2.4 MiscelleaneousRemarks . . . . . . . . . . . . . . . . . . 105
3
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 5: List of Tables

### List of Tables
### 3.1 HardwareExceptionsandSignals . . . . . . . . . . . . . . . . . 24
### 3.2 Floating-PointExceptions . . . . . . . . . . . . . . . . . . . . . 24
### 3.3 x87Floating-PointControlWord . . . . . . . . . . . . . . . . . . 26
### 3.4 MXCSRStatusBits . . . . . . . . . . . . . . . . . . . . . . . . . 27
### 3.5 rFLAGSBits . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
### 4.1 AMD64Identification . . . . . . . . . . . . . . . . . . . . . . . . 58
### 4.2 AMD64specificsectionheaderflag,sh_flags . . . . . . . . . 59
### 4.3 Sectionheadertypes . . . . . . . . . . . . . . . . . . . . . . . . 59
### 4.4 Specialsections . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
### 4.5 Additionalspecialsectionsforthelargecodemodel . . . . . . . . 60
### 4.6 CommonInformationEntry(CIE) . . . . . . . . . . . . . . . . . 62
### 4.7 CIEaugmentationsectioncontent . . . . . . . . . . . . . . . . . 63
### 4.8 FrameDescriptorEntry(FDE) . . . . . . . . . . . . . . . . . . . 64
### 4.9 FDEaugmentationsectioncontent . . . . . . . . . . . . . . . . . 65
### 4.10 RelocationTypes . . . . . . . . . . . . . . . . . . . . . . . . . . 68
### 5.1 Programheadertypes . . . . . . . . . . . . . . . . . . . . . . . . 72
### 7.1 Predefinedpre-processorsymbols . . . . . . . . . . . . . . . . . 98
4
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 6: List of Figures

### List of Figures
### 3.1 ScalarTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
### 3.2 Bit-FieldRanges . . . . . . . . . . . . . . . . . . . . . . . . . . 14
### 3.3 StackFramewithBasePointer . . . . . . . . . . . . . . . . . . . 15
### 3.4 RegisterUsage . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
### 3.5 ParameterPassingExample . . . . . . . . . . . . . . . . . . . . . 22
### 3.6 RegisterAllocationExample . . . . . . . . . . . . . . . . . . . . 22
### 3.7 VirtualAddressConfiguration . . . . . . . . . . . . . . . . . . . 25
### 3.8 ConventionalSegmentArrangements . . . . . . . . . . . . . . . 26
### 3.9 InitialProcessStack . . . . . . . . . . . . . . . . . . . . . . . . . 28
### 3.10 auxv_tTypeDefinition . . . . . . . . . . . . . . . . . . . . . . 29
### 3.11 AuxiliaryVectorTypes . . . . . . . . . . . . . . . . . . . . . . . 30
### 3.12 Position-independentfunctionprologcode . . . . . . . . . . . . . 35
### 3.13 AbsoluteLoadandStore(SmallModel) . . . . . . . . . . . . . . 37
### 3.14 Position-IndependendLoadandStore(SmallPICModel) . . . . . 38
### 3.15 AbsoluteLoadandStore(MediumModel) . . . . . . . . . . . . . 39
### 3.16 Position-IndependendLoadandStore(MediumPICModel) . . . 40
### 3.17 Position-IndependendLoadandStore(MediumPICModel),con-
tinued . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
### 3.18 Absoluteglobaldataloadandstore . . . . . . . . . . . . . . . . . 42
### 3.19 Fasterabsoluteglobaldataloadandstore . . . . . . . . . . . . . 42
### 3.20 Position-independendglobaldataloadandstore . . . . . . . . . . 43
### 3.21 Fasterposition-independendglobaldataloadandstore . . . . . . 43
### 3.22 Position-Independent Direct Function Call (Small and Medium
Model) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
### 3.23 Position-IndependentIndirectFunctionCall . . . . . . . . . . . . 44
### 3.24 Absolutedirectandindirectfunctioncall . . . . . . . . . . . . . . 45
### 3.25 Position-independentdirectandindirectfunctioncall . . . . . . . 45
### 3.27 Implicitcalculationoftargetaddress . . . . . . . . . . . . . . . . 47
5
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 7: 3.26 Absolutebranchingcode . . . . . . . . . . . . . . . . . . . . . . 47

### 3.26 Absolutebranchingcode . . . . . . . . . . . . . . . . . . . . . . 47
### 3.28 Position-independentbranchingcode . . . . . . . . . . . . . . . . 48
### 3.29 Absoluteswitchcode . . . . . . . . . . . . . . . . . . . . . . . . 48
### 3.30 Position-independentswitchcode . . . . . . . . . . . . . . . . . 49
### 3.31 ParameterPassingExamplewithVariable-ArgumentList . . . . . 50
### 3.32 RegisterAllocationExampleforVariable-ArgumentList . . . . . 50
### 3.33 RegisterSaveArea . . . . . . . . . . . . . . . . . . . . . . . . . 51
### 3.34 va_listTypeDeclaration . . . . . . . . . . . . . . . . . . . . 51
### 3.35 SampleImplementationofva_arg(l, int) . . . . . . . . . . 53
### 3.36 DWARFRegisterNumberMapping . . . . . . . . . . . . . . . . 55
### 3.37 Pointerencodingspecificationbyte . . . . . . . . . . . . . . . . . 57
### 4.1 RelocatableFields . . . . . . . . . . . . . . . . . . . . . . . . . . 66
### 4.2 Largemodelrelocationtypes . . . . . . . . . . . . . . . . . . . . 70
### 5.1 GlobalOffsetTable . . . . . . . . . . . . . . . . . . . . . . . . . 73
### 5.2 ProcedureLinkageTable(smallandmediummodels) . . . . . . . 75
### 5.3 FinallargecodemodelPLT . . . . . . . . . . . . . . . . . . . . . 77
### 6.1 Examplesforunwindinginassembler . . . . . . . . . . . . . . . 97
### 9.1 MappingofFortrantoCtypes . . . . . . . . . . . . . . . . . . . 102
A.1 RequiredProcessorFeatures . . . . . . . . . . . . . . . . . . . . 106
### Revision History
### 0.95 Include description of the medium PIC memory model (thanks to Jan Hu-
bicˇka)andlargemodel(thankstoEvandroMenezes).
### 0.94 Add sections in Development Environment, Program Loading, a escription
ofEH_FRAMEsectionsandgeneralcleanupstomaketextinthisABIself-
contained. ThankstoMichaelWalkerandTerrenceMiller.
### 0.93 Addsectionsaboutprogramheaders,newsectiontypesandspecialsections
forunwindinginformation. ThankstoMichaelWalker.
### 0.92 Fixsometypos(thankstoBryanFord),addsectionaboutstacklayoutinthe
Linux kernel. Fix example in figure 3.5 (thanks to Tom Horsley). Add sec-
tion on unwinding through assembler (written by Michal Ludvig). Remove
6
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 8: mmxext feature (thanks to Evandro Menezes). Add section on Fortran (by

mmxext feature (thanks to Evandro Menezes). Add section on Fortran (by
StevenBosscher)andstackunwinding(byJanHubicˇka).
### 0.91 Clarifythatx87isdefaultmode,notMMX(byHansPeterAnvin).
### 0.90 ChangeDWARFregisternumbersagain;mentionthat__m128needsalign-
ment; fix typo in figure 3.3; add some comments on kernel expectations;
mention TLS extensions; add example for passing of variable-argument
lists; change semantics of %rax in variable-argument lists; improve for-
matting; mention that X87 class is not used for passing; make /lib64 a
Linuxspecificsection;renamex86-64toAMD64;describepassingofcom-
plex types. Special thanks to Andi Kleen, Michal Ludvig, Michael Matz,
DavidO’BrienandEricYoungfortheircomments.
### 0.21 Define __int128 as class INTEGER in register passing. Mention that
```
%alisusedforvariadicargumentlists. Fixsometextualproblems. Thanks
```
toH.PeterAnvin,BoThorsen,andMichaelMatz.
0.20—2002-07-11 Change DWARF register number values of %rbx, %rsi,
```
%rsi (thanks to Michal Ludvig). Fix footnotes for fundamental types
```
(thanks to H. Peter Anvin). Specify size_t (thanks to Bo Thorsen and
Andreas Schwab). Add new section on floating point environment func-
tions.
0.19—2002-03-27 Set name of Linux dynamic linker, mention %fs. Incorpo-
rate changes from H. Peter Anvin <hpa@zytor.com> for booleans and de-
finehandlingofsub-64-bitintegertypesinregisters.
7
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 9: Chapter 1

### Chapter 1
### Introduction
TheAMD641 architecture2 isanextensionofthex86architecture. Anyprocessor
implementing the AMD64 architecture specification will also provide compatib-
litymodesforpreviousdescendantsoftheIntel8086architecture,including32-bit
processors such as the Intel 386, Intel Pentium, and AMD K6-2 processor. Oper-
ating systems conforming to the AMD64 ABI may provide support for executing
programs that are designed to execute in these compatiblity modes. The AMD64
ABIdoesnotapplytosuchprorams;thisdocumentappliesonlyprogramsrunning
inthe“long”modeprovidedbytheAMD64architecture.
Exceptwhereotherwisenoted,theAMD64architectureABIfollowsthecon-
ventions described in the Intel386 ABI. Rather than replicate the entire contents
of the Intel386 ABI, the AMD64 ABI indicates only those places where changes
havebeenmadetotheIntel386ABI.
NoattempthasbeenmadetospecifyanABIforlanguagesotherthanC.How-
ever, it is assumed that many programming languages will wish to link with code
writteninC,sothattheABIspecificationsdocumentedherearerelevant.3
### 1.1 Differences from the Intel386 ABI
ThemostfundamentaldifferencesfromtheIntel386ABIdocumentareasfollows:
1AMD64hasbeenpreviouslycalledx86-64. Thelatternameisusedinanumberofplacesout
ofhistoricalreasonsinsteadofAMD64.
2The architecture specification is available on the web at http://www.x86-64.org/
documentation.
3Seesection9.2fordetailsonC++ABI.
8
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 10: • Sizesoffundamentaldatatypes.

- Sizesoffundamentaldatatypes.
- Parameter-passingconventions.
- Floating-pointcomputations.
- RemovaloftheGOTregister.
- UseofRELArelocations.
9
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 11: Chapter 2

### Chapter 2
Software Installation
Nochangesrequired.
10
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 12: Chapter 3

### Chapter 3
Low Level System Information
### 3.1 Machine Interface
### 3.1.1 Processor Architecture
### 3.1.2 Data Representation
Within this specification, the term byte refers to a 8-bit object, the term twobyte
refers to a 16-bit object, the term fourbyte refers to a 32-bit object, the term
eightbyte refers to a 64-bit object, and the term sixteenbyte refers to a 128-bit
object.1
FundamentalTypes
Figure3.1showsthecorrespondencebetweenISOC’sscalartypesandtheproces-
sor’s. The__int128,__float128,__m64and__m128typesareoptional.
The __float128 type uses a 15-bit exponent, a 113-bit mantissa (the high
```
ordersignificantbitisimplicit)andanexponentbiasof16383.2
```
Thelong doubletypeusesa15bitexponent,a64-bitmantissawithanex-
plicithighordersignificantbitandanexponentbiasof16383.3 Althoughalong
1The Intel386 ABI uses the term halfword for a 16-bit object, the term word for a 32-bit
object,thetermdoubleword fora64-bitobject.ButmostIA-32processorspecificdocumentation
defineaword asa16-bitobject,adoubleword asa32-bitobject,aquardword asa64-bitobject
```
andadoublequadword asa128-bitobject.
```
2InitialimplementationsoftheAMD64architectureareexpectedtosupportoperationsonthe
__float128typeonlyviasoftwareemulation.
3Thistypeisthex87doubleextendedprecisiondatatype.
11
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 13: Figure3.1: ScalarTypes

Figure3.1: ScalarTypes
Alignment AMD64
Type C sizeof (bytes) Architecture
_Bool† 1 1 boolean
char 1 1 signedbyte
signed char
unsigned char 1 1 unsignedbyte
short 2 2 signedtwobyte
signed short
unsigned short 2 2 unsignedtwobyte
int 4 4 signedfourbyte
Integral signed int
```
enum
```
unsigned int 4 4 unsignedfourbyte
long 8 8 signedeightbyte
signed long
long long
signed long long
unsigned long 8 8 unsignedeightbyte
unsigned long long 8 8 unsignedeightbyte
__int128†† 16 16 signedsixteenbyte
signed __int128†† 16 16 signedsixteenbyte
unsigned __int128†† 16 16 unsignedsixteenbyte
Pointer any-type * 8 8 unsignedeightbyte
any-type (*)()
Floating- float 4 4 single(IEEE)
point double 8 8 double(IEEE)
long double 16 16 80-bitextended(IEEE)
__float128†† 16 16 128-bitextended(IEEE)
Packed __m64†† 8 8 MMX and3DNow!
__m128†† 16 16 SSEandSSE-2
† ThistypeiscalledboolinC++.
†† Thesetypesareoptional.
12
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 14: double requires 16 bytes of storage, only the first 10 bytes are significant. The

double requires 16 bytes of storage, only the first 10 bytes are significant. The
remainingsixbytesaretailpadding,andthecontentsofthesebytesareundefined.
The __int128 type is stored in little-endian order in memory, i.e., the 64
low-orderbitsarestoredataaloweraddressthanthe64high-orderbits.
Anullpointer(foralltypes)hasthevaluezero.
Thetypesize_t isdefinedasunsigned long.
Booleans,whenstoredinamemoryobject,arestoredassinglebyteobjectsthe
valueofwhichisalways0(false)or1(true). Whenstoredinintegerregisters
```
orpassedasargumentsonthestack,all8bytesoftheregisteraresignificant;any
```
nonzerovalueisconsideredtrue.
Like the Intel386 architecture, the AMD64 architecture in general does not
require all data access to be properly aligned. Accessing misaligned data will be
slower than accessing properly aligned data, but otherwise there is no difference.
Theonlyexceptionhereisthat__m128alwayshastobealignedproperly.
AggregatesandUnions
Structures and unions assume the alignment of their most strictly aligned compo-
nent. Each member is assigned to the lowest available offset with the appropriate
alignment. Thesizeofanyobjectisalwaysamultipleoftheobject‘salignment.
Anarrayusesthesamealignmentasitselements,exceptthatalocalorglobal
array variable that requires at least 16 bytes, or a C99 local or global variable-
lengtharrayvariable,alwayshasalignmentofatleast16bytes.4
Structure and union objects can require padding to meet size and alignment
constraints. Thecontentsofanypaddingisundefined.
Bit-Fields
C struct and union definitions may include bit-fields that define integral values of
aspecifiedsize.
The ABI does not permit bitfields having the type __m64 or __m128. Pro-
gramsusingbitfieldsofthesetypesarenotportable.
Bit-fields that are neither signed nor unsigned always have non-negative val-
ues. Although they may have type char, short, int, or long (which can have neg-
4The alignment requirement allows the use of SSE instructions when operating on the array.
The compiler cannot in general calculate the size of a variable-length array (VLA), but it is ex-
pectedthatmostVLAswillrequireatleast16bytes,soitislogicaltomandatethatVLAshaveat
```
leasta16-bytealignment.
```
13
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 15: Figure3.2: Bit-FieldRanges

Figure3.2: Bit-FieldRanges
Bit-fieldType Widthw Range
signed long −2w−1 to2w−1 −1
long 1to64 0to2w −1
unsigned long 0to2w −1
ative values), these bit-fields have the same range as a bit-field of the same size
withthecorrespondingunsignedtype. Bit-fieldsobeythesamesizeandalignment
rulesasotherstructureandunionmembers.
Also
- bit-fieldsareallocatedfromrighttoleft
- bit-fields must be contained in a storage unit appropriate for its declared
type
- bit-fieldsmayshareastorageunitwithotherstruct/unionmembers
Unnamedbit-fields’typesdonotaffectthealignmentofastructureorunion.
### 3.2 Function Calling Sequence
This section describes the standard function calling sequence, including stack
framelayout,registerusage,parameterpassingandsoon.
The standard calling sequence requirements apply only to global functions.
Local functions that are not reachable from other compilation units may use dif-
ferent conventions. Nevertheless, it is recommended that all functions use the
standardcallingsequencewhenpossible.
### 3.2.1 Registers and the Stack Frame
TheAMD64architectureprovides16generalpurpose64-bitregisters. Inaddition
the architecture provides 16 SSE registers, each 128 bits wide and 8 x87 floating
point registers, each 80 bits wide. Each of the x87 floating point registers may be
14
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 16: Figure3.3: StackFramewithBasePointer

Figure3.3: StackFramewithBasePointer
Position Contents Frame
8n+16(%rbp) argumenteightbyten
```
... Previous
```
16(%rbp) argumenteightbyte0
8(%rbp) returnaddress
0(%rbp) previous%rbpvalue
-8(%rbp) unspecified Current
```
...
```
0(%rsp) variablesize
-128(%rsp) redzone
referred to in MMX/3DNow! mode as a 64-bit register. All of these registers are
globaltoallproceduresinarunningprogram.
This subsection discusses usage of each register. Registers %rbp, %rbx and
```
%r12 through %r15 “belong” to the calling function and the called function is
```
required to preserve their values. In other words, a called function must preserve
these registers’ values for its caller. Remaining registers “belong” to the called
function.5 If a calling function wants to preserve such a register value across a
functioncall,itmustsavethevalueinitslocalstackframe.
The CPU shall be in x87 mode upon entry to a function. Therefore, every
function that uses the MMX registers is required to issue an emms or femms
instructionafterusingMMXregisters,beforereturningorcallinganotherfunction.
### 6 Thedirectionflaginthe%eflagsregistermustbeclearonfunctionentry,and
onfunctionreturn.
### 3.2.2 The Stack Frame
Inadditiontoregisters,eachfunctionhasaframeontherun-timestack. Thisstack
growsdownwardsfromhighaddresses. Figure3.3showsthestackorganization.
5NotethatincontrasttotheIntel386ABI,%rdi,and%rsibelongtothecalledfunction,not
thecaller.
6Allx87registersarecaller-saved,socalleesthatmakeuseoftheMMX registersmayusethe
fasterfemmsinstruction.
15
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 17: The end of the input argument area shall be aligned on a 16 byte boundary.

The end of the input argument area shall be aligned on a 16 byte boundary.
In other words, the value (%rsp−8) is always a multiple of 16 when control is
transferred to the function entry point. The stack pointer, %rsp, always points to
theendofthelatestallocatedstackframe. 7
The 128-byte area beyond the location pointed to by %rsp is considered to
be reserved and shall not be modified by signal or interrupt handlers.8 Therefore,
functions may use this area for temporary data that is not needed across function
```
calls. In particular, leaf functions may use this area for their entire stack frame,
```
rather than adjusting the stack pointer in the prologue and epilogue. This area is
knownasredzone.
### 3.2.3 Parameter Passing
After the argument values have been computed, they are placed in registers, or
```
pushedonthestack. Thewayhowvaluesarepassedisdescribedinthefollowing
```
sections.
Definitions We first define a number of classes to classify arguments. The
classesarecorrespondingtoAMD64registerclassesanddefinedas:
INTEGER This class consists of integral types that fit into one of the general
purposeregisters.
SSE TheclassconsistsoftypesthatfitsintoaSSEregister.
SSEUP The class consists of types that fit into a SSE register and can be passed
```
andreturnedinthemostsignificanthalfofit.
```
X87,X87UP These classes consists of types that will be returned via the x87
FPU.
COMPLEX_X87 This class consists of types that will be returned via the x87
FPU.
NO_CLASS Thisclassisusedasinitializerinthealgorithms. Itwillbeusedfor
paddingandemptystructuresandunions.
7Theconventionaluseof%rbpasaframepointerforthestackframemaybeavoidedbyusing
```
%rsp (the stack pointer)to index into the stack frame. This technique savestwo instructions in
```
theprologueandepilogueandmakesoneadditionalgeneral-purposeregister(%rbp)available.
8Locationswithin128bytescanbeaddressedusingone-bytedisplacements.
16
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 18: MEMORY Thisclassconsistsoftypesthatwillbepassedandreturnedinmem-

MEMORY Thisclassconsistsoftypesthatwillbepassedandreturnedinmem-
```
oryviathestack.
```
Classification Thesizeofeachargumentgetsroundeduptoeightbytes.9
Thebasictypesareassignedtheirnaturalclasses:
- Arguments of types (signed and unsigned) _Bool, char, short, int,
long,long long,andpointersareintheINTEGERclass.
- Argumentsoftypesfloat,doubleand__m64areinclassSSE.
- Arguments of types __float128 and __m128 are split into two halves.
The least significant ones belong to class SSE, the most significant one to
classSSEUP.
- The 64-bit mantissa of arguments of type long double belongs to class
X87,the16-bitexponentplus6bytesofpaddingbelongstoclassX87UP.
- Arguments of type __int128 offer the same operations as INTEGERs,
yettheydonotfitintoonegeneralpurposeregisterbutrequiretworegisters.
For classification purposes __int128 is treated as if it were implemented
as:
```
typedef struct {
long low, high;
} __int128;
```
with the exception that arguments of type __int128 that are stored in
memorymustbealignedona16-byteboundary.
- Argumentsofcomplex TwhereTisoneofthetypesfloat or double
aretreatedasiftheyareimplementedas:
```
struct complexT {
```
T real;
T imag;
};
9Thereforethestackwillalwaysbeeightbytealigned.
17
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 19: • A variable of type complex long double is classified as type COM-

- A variable of type complex long double is classified as type COM-
PLEX_X87.
The classification of aggregate (structures and arrays) and union types works
asfollows:
1. If the size of an object is larger than two eightbytes, or in C++, is a non-
POD 10 structure or union type, or contains unaligned fields, it has class
MEMORY.11
2. BotheightbytesgetinitializedtoclassNO_CLASS.
3. Eachfieldofanobjectisclassifiedrecursivelysothatalwaystwofieldsare
considered. The resulting class is calculated according to the classes of the
fieldsintheeightbyte:
(a) Ifbothclassesareequal,thisistheresultingclass.
(b) If one of the classes is NO_CLASS, the resulting class is the other
class.
(c) IfoneoftheclassesisMEMORY,theresultistheMEMORYclass.
(d) IfoneoftheclassesisINTEGER,theresultistheINTEGER.
(e) If one of the classes is X87, X87UP, COMPLEX_X87 class, MEM-
ORYisusedasclass.
(f) OtherwiseclassSSEisused.
4. Thenapostmergercleanupisdone:
(a) If one of the classes is MEMORY, the whole argument is passed in
memory.
(b) IfSSEUPisnotpreceededbySSE,itisconvertedtoSSE.
10ThetermPODisfromtheANSI/ISOC++Standard,andstandsforPlainOldData. Although
the exact definition is technical, a POD is essentially a structure or union that could have been
writteninC;therecannotbeanymemberfunctions,orbaseclasses,orsimilarC++extensions.
11Anon-PODobjectcannotbepassedinregistersbecausesuchobjectsmusthavewelldefined
```
addresses; the address at which an object is constructed (by the caller) and the address at which
```
the object is destroyed (by the callee) must be the same. Similar issues apply when returning a
non-PODobjectfromafunction.
18
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 20: Passing Onceargumentsareclassified,theregistersgetassigned(inleft-to-right

Passing Onceargumentsareclassified,theregistersgetassigned(inleft-to-right
```
order)forpassingasfollows:
```
1. IftheclassisMEMORY,passtheargumentonthestack.
2. If the class is INTEGER, the next available register of the sequence %rdi,
```
%rsi,%rdx,%rcx,%r8and%r9isused12.
```
3. If the class is SSE, the next available SSE register is used, the registers are
takenintheorderfrom%xmm0to%xmm7.
4. If the class is SSEUP, the eightbyte is passed in the upper half of the last
usedSSEregister.
5. IftheclassisX87,X87UPorCOMPLEX_X87,itispassedinmemory.
If there is no register available anymore for any eightbyte of an argument, the
wholeargumentispassedonthestack. Ifregistershavealreadybeenassignedfor
someeightbytesofthisargument,thoseassignmentsgetreverted.
Once registers are assigned, the arguments passed in memory are pushed on
thestackinreversed(right-to-left13)order.
For calls that may call functions that use varargs or stdargs (prototype-less
```
callsorcallstofunctionscontainingellipsis(...) inthedeclaration)%al14isused
```
as hidden argument to specify the number of SSE registers used. The contents of
```
%al do not need to match exactly the number of registers, but must be an upper
```
boundonthenumberofSSEregistersusedandisintherange0–8inclusive.
ReturningofValues Thereturningofvaluesisdoneaccordingtothefollowing
algorithm:
1. Classifythereturntypewiththeclassificationalgorithm.
12Notethat%r11isneitherrequiredtobepreserved,norisitusedtopassarguments. Making
this register available as scratch register means that code in the PLT need not spill any registers
whencomputingtheaddresstowhichcontrolneedstobetransferred.%raxisusedtoindicatethe
numberofSSEargumentspassedtoafunctionrequiringavariablenumberofarguments. %r10
isusedforpassingafunction’sstaticchainpointer.
13Right-to-leftorderonthestackmakesthehandlingoffunctionsthattakeavariablenumber
ofargumentssimpler. Thelocationofthefirstargumentcanalwaysbecomputedstatically,based
onthetypeofthatargument. Itwouldbedifficulttocomputetheaddressofthefirstargumentif
theargumentswerepushedinleft-to-rightorder.
14Notethattherestof%raxisundefined,onlythecontentsof%alisdefined.
19
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 21: Figure3.4: RegisterUsage

Figure3.4: RegisterUsage
Preservedacross
Register Usage functioncalls
```
%rax temporary register; with variable ar- No
```
gumentspassesinformationaboutthe
number of SSE registers used; 1st re-
turnregister
```
%rbx callee-saved register; optionally used Yes
```
asbasepointer
```
%rcx used to pass 4th integer argument to No
```
functions
```
%rdx used to pass 3rd argument to func- No
```
tions;2nd returnregister
```
%rsp stackpointer Yes
%rbp callee-saved register; optionally used Yes
```
asframepointer
```
%rsi used to pass 2nd argument to func- No
```
tions
```
%rdi usedtopass1st argumenttofunctions No
%r8 usedtopass5th argumenttofunctions No
%r9 usedtopass6th argumenttofunctions No
%r10 temporary register, used for passing a No
```
function’sstaticchainpointer
```
%r11 temporaryregister No
%r12-r15 callee-savedregisters Yes
%xmm0–%xmm1 used to pass and return floating point No
```
arguments
```
%xmm2–%xmm7 usedtopassfloatingpointarguments No
%xmm8–%xmm15 temporaryregisters No
%mmx0–%mmx7 temporaryregisters No
%st0 temporary register; used to return No
```
long doublearguments
```
%st1 temporary registers; used to return No
```
long doublearguments
```
%st2–%st7 temporaryregisters No
%fs Reserved for system use (as thread No
```
specificdataregister)
20
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 22: 2. IfthetypehasclassMEMORY,thenthecallerprovidesspaceforthereturn

2. IfthetypehasclassMEMORY,thenthecallerprovidesspaceforthereturn
value and passes the address of this storage in %rdi as if it were the first
argument to the function. In effect, this address becomes a “hidden” first
argument.
On return %rax will contain the address that has been passed in by the
```
callerin%rdi.
```
3. If the class is INTEGER, the next available register of the sequence %rax,
```
%rdxisused.
```
4. If the class is SSE, the next available SSE register of the sequence %xmm0,
```
%xmm1isused.
```
5. If the class is SSEUP, the eightbyte is passed in the upper half of the last
usedSSEregister.
6. IftheclassisX87,thevalueisreturnedontheX87stackin%st0as80-bit
x87number.
7. If the class is X87UP, the value is returned together with the previous X87
valuein%st0.
8. If the class is COMPLEX_X87, the real part of the value is returned in
```
%st0andtheimaginarypartin%st1.
```
As an example of the register passing conventions, consider the declarations
```
and the function call shown in Figure 3.5. The corresponding register allocation
```
isgiveninFigure3.6,thestackframeoffsetgivenshowstheframebeforecalling
thefunction.
21
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 23: Figure3.5: ParameterPassingExample

Figure3.5: ParameterPassingExample
```
typedef struct {
int a, b;
```
double d;
```
} structparm;
structparm s;
int e, f, g, h, i, j, k;
long double ld;
```
double m, n;
extern void func (int e, int f,
```
structparm s, int g, int h,
```
long double ld, double m,
```
double n, int i, int j, int k);
func (e, f, s, g, h, ld, m, n, i, j, k);
```
Figure3.6: RegisterAllocationExample
GeneralPurposeRegisters FloatingPointRegisters StackFrameOffset
```
%rdi: e %xmm0: s.d 0: ld
%rsi: f %xmm1: m 16: j
%rdx: s.a,s.b %xmm2: n 24: k
%rcx: g
%r8: h
%r9: i
```
22
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 24: 3.3 Operating System Interface

### 3.3 Operating System Interface
### 3.3.1 Exception Interface
As the AMD64 manuals describe, the processor changes mode to handle excep-
tions, which may be synchronous, floating-point/coprocessor or asynchronous.
Synchronous and floating-point/coprocessor exceptions, being caused by instruc-
tion execution, can be explicitly generated by a process. This section, therefore,
specifies those exception types with defined behavior. The AMD64 architecture
classifies exceptions as faults, traps, and aborts. See the Intel386 ABI for more
informationabouttheirdifferences.
HardwareExceptionTypes
The operating system defines the correspondence between hardware exceptions
```
and the signals specified by signal (BA_OS) as shown in table 3.1. Contrary
```
tothei386architecture,theAMD64doesnotdefineanyinstructionsthatgenerate
aboundscheckfaultinlongmode.
### 3.3.2 Virtual Address Space
AlthoughtheAMD64architectureuses64-bitpointers,implementationsareonly
required to handle 48-bit addresses. Therefore, conforming processes may only
useaddressesfrom0x0000000000000000to0x00007fffffffffff15.
Processes begin with three logical segments, commonly called text, data, and
stack. Use of shared libraries add other segments and a process may dynamically
createsegments.
### 3.3.3 Page Size
Systemsarepermittedtouseanypower-of-twopagesizebetween4KBand64KB,
inclusive.
### 3.3.4 Virtual Address Assignments
Conceptually processes have the full address space available. In practice, how-
ever,severalfactorslimitthesizeofaprocess.
150x0000ffffffffffffisnotacanonicaladdressandcannotbeused.
23
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 25: Table3.1: HardwareExceptionsandSignals

Table3.1: HardwareExceptionsandSignals
Number Exceptionname Signal
### 0 divide error fault SIGFPE
### 1 single step trap/fault SIGTRAP
### 2 nonmaskable interrupt none
### 3 breakpoint trap SIGTRAP
### 4 overflow trap SIGSEGV
5 (reserved)
### 6 invalid opcode fault SIGILL
### 7 no coprocessor fault SIGFPE
### 8 double fault abort none
### 9 coprocessor overrun abort SIGSEGV
### 10 invalid TSS fault none
### 11 segment no present fault none
### 12 stack exception fault SIGSEGV
### 13 general protection fault/abort SIGSEGV
### 14 page fault SIGSEGV
15 (reserved)
### 16 coprocessor error fault SIGFPE
other (unspecified) SIGILL
Table3.2: Floating-PointExceptions
Code Reason
FPE_FLTDIV floating-point divide by zero
FPE_FLTOVF floating-point overflow
FPE_FLTUND floating-point underflow
FPE_FLTRES floating-point inexact result
FPE_FLTINV invalid floating-point operation
24
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 26: • Thesystemreservesaconfigurationdependentamountofvirtualspace.

- Thesystemreservesaconfigurationdependentamountofvirtualspace.
- Thesystemreservesaconfigurationdependentamountofspaceperprocess.
- A process whose size exceeds the system’s available combined physical
memory and secondary storage cannot run. Although some physical mem-
```
ory must be present to run any process, the system can execute processes
```
that are bigger than physical memory, paging them to and from secondary
storage. Nonetheless, both physical memory and secondary storage are
shared resources. System load, which can vary from one program execu-
tiontothenext,affectstheavailableamount.
Programs that dereference null pointers are erroneous and a process should
notexpect0x0tobeavalidaddress.
Figure3.7: VirtualAddressConfiguration
0xffffffffffffffff Reservedsystemarea Endofmemory
```
...
...
```
0x80000000000 Dynamicsegments
```
...
```
0 Processsegments Beginningofmemory
Although applications may control their memory assignments, the typical ar-
rangementappearsinfigure3.8.
25
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 27: Figure3.8: ConventionalSegmentArrangements

Figure3.8: ConventionalSegmentArrangements
```
...
```
0x80000000000 Dynamicsegments
Stacksegment
```
...
...
```
Datasegments
```
...
```
0x400000 Textsegments
### 0 Unmapped
### 3.4 Process Initialization
### 3.4.1 Initial Stack and Register State
SpecialRegisters
The AMD64 architecture defines floating point instructions. At process startup
the two floating point units, SSE2 and x87, both have all floating-point exception
statusflagscleared. Thestatusofthecontrolwordsisasdefinedintables3.3and
3.4.
Table3.3: x87Floating-PointControlWord
Field Value Note
RC 0 Roundtonearest
PC 11 Doubleextendedprecision
PM 1 Precisionmasked
UM 1 Underflowmasked
OM 1 Overflowmasked
ZM 1 Zerodividemasked
DM 1 Denormaloperandmasked
IM 1 Invalidoperationmasked
26
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 28: Table3.4: MXCSRStatusBits

Table3.4: MXCSRStatusBits
Field Value Note
FZ 0 Donotflushtozero
RC 0 Roundtonearest
PM 1 Precisionmasked
UM 1 Underflowmasked
OM 1 Overflowmasked
ZM 1 Zerodividemasked
DM 1 Denormaloperandmasked
IM 1 Invalidoperationmasked
DAZ 0 Denormalsarenotzero
The rFLAGS register contains the system flags, such as the direction flag and
the carry flag. The low 16 bits (FLAGS portion) of rFLAGS are accessible by
application software. The state of them at process initialization is shown in table
3.5.
Table3.5: rFLAGSBits
Field Value Note
DF 0 Directionforward
CF 0 Nocarry
PF 0 Evenparity
AF 0 Noauxiliarycarry
ZF 0 Nozeroresult
SF 0 Unsignedresult
OF 0 Nooverflowoccured
The direction flag DF must be set to the “forward” direction (that is to zero)
beforeentryanduponexitfromafunction. Otheruserflagshavenospecifiedrole
inthestandardcallingsequenceandarenotpreserved.
27
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 29: StackState

StackState
This section describes the machine state that exec (BA_OS) creates for new
processes. Various language implementations transform this initial program state
tothestaterequiredbythelanguagestandard.
For example, a C program begins executing at a function named main de-
claredas:
```
extern int main ( int argc , char *argv[ ] , char* envp[ ] );
```
where
argc isanon-negativeargumentcount
argv isanarrayofargumentstrings,withargv[argc] == 0
envp isanarrayofenvironmentstrings,terminatedbyanullpointer.
When main() returns its value is passed to exit() and if that has been
over-riddenandreturns,_exit()(whichmustbeimmunetouserinterposition).
The initial state of the process stack, i.e. when _start is called is shown in
figure3.9.
Figure3.9: InitialProcessStack
Purpose StartAddress Length
Unspecified HighAddresses
Information block, including argu- varies
ment strings, environment strings,
auxiliaryinformation...
Unspecified
Nullauxiliaryvectorentry 1eightbyte
Auxiliaryvectorentries... 2eightbyteseach
### 0 eightbyte
Environmentpointers... 1eightbyteeach
0 8+8*argc+%rsp eightbyte
Argumentpointers 8+%rsp argceightbytes
Argumentcount %rsp eightbyte
Undefined LowAddresses
28
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 30: Argument strings, environment strings, and the auxiliary information appear

Argument strings, environment strings, and the auxiliary information appear
in no specific order within the information block and they need not be compactly
allocated.
Onlytheregisterslistedbelowhavespecifiedvaluesatprocessentry:
```
%rbp The content of this register is unspecified at process initialization time,
```
but the user code should mark the deepest stack frame by setting the frame
pointertozero.
```
%rsp Thestackpointerholdstheaddressofthebytewithlowestaddresswhich
```
ispartofthestack. Itisguaranteedtobe16-bytealignedatprocessentry.
```
%rdx afunctionpointerthattheapplicationshouldregisterwithatexit(BA_OS).
```
It is unspecified wether the data and stack segments are initially mapped with
executepermissionsornot. Applicationswhichneedtoexecutecodeonthestack
```
ordatasegmentsshouldtakeproperprecautions,e.g.,bycallingmprotect().
```
3.4.2 Auxiliary Vector
The auxiliary vector is an array of the following structures (ref. figure 3.10),
interpretedaccordingtothea_typemember.
Figure3.10: auxv_tTypeDefinition
```
typedef struct
```
{
```
int a_type;
union {
long a_val;
void *a_ptr;
void (*a_fnc)();
```
} a_un;
} auxv_t;
TheAMD64ABIusestheauxiliaryvectortypesdefinedinfigure3.11.
29
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 31: Figure3.11: AuxiliaryVectorTypes

Figure3.11: AuxiliaryVectorTypes
Name Value a_un
AT_NULL 0 ignored
AT_IGNORE 1 ignored
AT_EXECFD 2 a_val
AT_PHDR 3 a_ptr
AT_PHENT 4 a_val
AT_PHNUM 5 a_val
AT_PAGESZ 6 a_val
AT_BASE 7 a_ptr
AT_FLAGS 8 a_val
AT_ENTRY 9 a_ptr
AT_NOTELF 10 a_val
AT_UID 11 a_val
AT_EUID 12 a_val
AT_GID 13 a_val
AT_EGID 14 a_val
AT_NULL Theauxiliaryvectorhasnofixedlength;insteaditslastentry’sa_type
memberhasthisvalue.
AT_IGNORE This type indicates the entry has no meaning. The corresponding
valueofa_unisundefined.
AT_EXECFD At process creation the system may pass control to an interpreter
program. When this happens, the system places either an entry of type
AT_EXECFD or one of type AT_PHDR in the auxiliary vector. The entry
for type AT_EXECFD uses the a_val member to contain a file descriptor
opentoreadtheapplicationprogram’sobjectfile.
AT_PHDR Thesystemmaycreatethememoryimageoftheapplicationprogram
before passing control to the interpreter program. When this happens, the
a_ptr member of the AT_PHDR entry tells the interpreter where to find
theprogramheadertableinthememoryimage.
30
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 32: AT_PHENT The a_val member of this entry holds the size, in bytes, of one

AT_PHENT The a_val member of this entry holds the size, in bytes, of one
entryintheprogramheadertabletowhichtheAT_PHDRentrypoints.
AT_PHNUM The a_val member of this entry holds the number of entries in
theprogramheadertabletowhichtheAT_PHDRentrypoints.
AT_PAGESZ Ifpresent,thisentry’sa_valmembergivesthesystempagesize,
inbytes.
AT_BASE Thea_ptrmemberofthisentryholdsthebaseaddressatwhichthe
interpreterprogramwasloadedintomemory. See“ProgramHeader”inthe
SystemVABIformoreinformationaboutthebaseaddress.
AT_FLAGS Ifpresent,thea_valmemberofthisentryholdsone-bitflags. Bits
withundefinedsemanticsaresettozero.
AT_ENTRY Thea_ptrmemberofthisentryholdstheentrypointoftheappli-
cationprogramtowhichtheinterpreterprogramshouldtransfercontrol.
AT_NOTELF The a_val member of this entry is non-zero if the program is in
anotherformatthanELF.
AT_UID Thea_valmemberofthisentryholdstherealuseridoftheprocess.
AT_EUID The a_val member of this entry holds the effective user id of the
process.
AT_GID Thea_valmemberofthisentryholdstherealgroupidoftheprocess.
AT_EGID The a_val member of this entry holds the effective group id of the
process.
### 3.5 Coding Examples
This section discusses example code sequences for fundamental operations such
as calling functions, accessing static objects, and transferring control from one
partofaprogramtoanother. Unlikepreviousmaterial,thismaterialisnotnorma-
tive. ItshowsonlythedifferencetotheIntel386ABI.
31
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 33: 3.5.1 Architectural Constraints

### 3.5.1 Architectural Constraints
The AMD64 architecture usually does not allow to encode arbitrary 64-bit con-
stants as immediate operand of the instruction. Most instructions accept 32-bit
immediates that are sign extended to the 64-bit ones. Additionally the 32-bit op-
erationswithregisterdestinationsimplicitlyperformzeroextensionmakingloads
of64-bitimmediateswithupperhalfsetto0evencheaper.
Additionally the branch instructions accept 32-bit immediate operands that
are sign extended and used to adjust instruction pointer. Similarly an instruction
pointer relative addressing mode exists for data accesses with equivalent limita-
tions.
In order to improve performance and reduce code size, it is desirable to use
differentcodemodelsdependingontherequirements.
Codemodelsdefineconstraintsforsymbolicvaluesthatallowthecompilerto
generate better code. Basically code models differ in addressing (absolute versus
position independent), code size, data size and address range. We define only a
smallnumberofcodemodelsthatareofgeneralinterest:
Smallcodemodel The virtual address of code executed is known at link time.
Additionallyallsymbolsareknowntobelocatedinthevirtualaddressesin
therangefrom0to231 −224 −1.
This allows the compiler to encode symbolic references with offsets in the
range from −231 to 224 directly in the sign extended immediate operands,
withoffsetsintherangefrom0to231−224 inthezeroextendedimmediate
operands and use instruction pointer relative addressing for the symbols
withoffsetsintherange−224 to224.
This is the fastest code model and we expect it to be suitable for the vast
majorityofprograms.
Kernelcodemodel Thekernelofanoperatingsystemisusuallyrathersmallbut
runs in the negative half of the address space. So we define all symbols to
beintherangefrom264 −231 to264 −224.
This code model has advantages similar to those of the small model, but
allowsencodingofzeroextendedsymbolicreferencesonlyforoffsetsfrom
### 231 to 231 + 224. The range offsets for sign extended reference changes to
0–231 +224.
Mediumcodemodel In the medium model, the data section is split into two
parts — the data section still limited in the same way as in the small code
32
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 34: model and the large data section having no limits except for available ad-

model and the large data section having no limits except for available ad-
dressing space. The program layout must be set in a way so that large data
sections (.ldata, .lrodata, .lbss) come after the text and data sec-
tions.
This model requires the compiler to use movabs instructions to access
large static data and to load addresses into registers, but keeps the advan-
tages of the small code model for manipulation of addresses in the small
dataandtextsections(speciallyneededforbranches).
Bydefaultonlydatalargerthan65535byteswillbeplacedinthelargedata
section.
Largecodemodel Thelargecodemodelmakesnoassumptionsaboutaddresses
```
andsizesofsections.
```
The compiler is required to use the movabs instruction, as in the medium
code model, even for dealing with addresses inside the text section. Addi-
tionally, indirect branches are needed when branching to addresses whose
offsetfromthecurrentinstructionpointerisunknown.
It is possible to avoid the limitation on the text section in the small and
medium models by breaking up the program into multiple shared libraries,
sothismodelisstrictlyonlyrequiredifthetextofasinglefunctionbecomes
largerthanwhatthemediummodelallows.
Smallpositionindependentcodemodel(PIC) Unlikethepreviousmodels,the
virtual addresses of instructions and data are not known until dynamic link
time. Soalladdresseshavetoberelativetotheinstructionpointer.
Additionally the maximum distance between a symbol and the end of an
instructionislimitedto231−224−1,allowingthecompilertouseinstruction
pointer relative branches and addressing modes supported by the hardware
foreverysymbolwithanoffsetintherange−224 to224.
Mediumpositionindependentcodemodel(PIC) This model is like the previ-
ousmodel,butsimilarlytothemediumstaticmodeladdslargedatasections
attheendofobjectfiles.
In the medium PIC model, the instruction pointer relative addressing can
not be used directly for accessing large static data, since the offset can ex-
ceed the limitations on the size of the displacement field in the instruction.
33
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 35: Insteadanunwindsequenceconsistingofmovabs,leaandaddneedsto

Insteadanunwindsequenceconsistingofmovabs,leaandaddneedsto
beused.
Largepositionindependentcodemodel(PIC) This model is like the previous
model,butmakesnoassumptionsaboutthedistanceofsymbols.
ThelargePICmodelimpliesthesamelimitationasthemediumPICmodel
regarding addressing of static data. Additionally, references to the global
offsettableandtotheprocedurelinkagetableandbranchdestinationsneed
to be calculated in a similar way. Further the size of the text segment is
allowed to be up to 16EB in size, hence similar restrictions apply to all
```
addressreferencesintothetextsegments,includingbranches.
```
3.5.2 Conventions
Inthisdocumentsomespecialassemblersymbolsareusedinthecodingexamples
```
anddicussion. Theyare:
- name@GOT: specifies the offset to the GOT entry for the symbol name
```
fromthebaseoftheGOT.
- name@GOTPLT:specifiestheoffsettotheGOTentryforthesymbolname
fromthebaseoftheGOT,implyingthatthereisacorrespondingPLTentry.
- name@GOTOFF: specifies the offset to the location of the symbol name
fromthebaseoftheGOT.
- name@GOTPCREL: specifies the offset to the GOT entry for the symbol
namefromthecurrentcodelocation.
- name@PLT:specifiestheoffsettothePLTentryofsymbolnamefromthe
currentcodelocation.
- name@PLTOFF:specifiestheoffsettothePLTentryofsymbolnamefrom
thebaseoftheGOT.
- _GLOBAL_OFFSET_TABLE_: specifies the offset to the base of the GOT
fromthecurrentcodelocation.
34
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 36: 3.5.3 Position-Independent Function Prologue

### 3.5.3 Position-Independent Function Prologue
In the small code model AMD64 does not need any function prologue for cal-
culating the global offset table address since it does not have an explicit GOT
pointer.
In the medium and large code models a register has to be allocated to hold
theaddressoftheGOTinposition-independentobjects,becausetheAMD64ISA
doesnotsupportanimmediatedisplacementlargerthan32bits.
As %r15 is preserved across function calls, it is initialized in the function
prologtoholdtheGOTaddress16fornon-leaffunctionswhichcallotherfunctions
through the PLT. Other functions are free to use any other register. Throughout
thisdocument,%r15willbeusedinexamples.
Figure3.12: Position-independentfunctionprologcode
mediummodel:
```
leaq _GLOBAL_OFFSET_TABLE_(%rip),%r15 # GOTPC32 reloc
```
largemodel:
```
pushq %r15 # save %r15
leaq 1f(%rip),%r11 # absolute %rip
```
1: movabs $_GLOBAL_OFFSET_TABLE_,%r15 # offset to the GOT (R_X86_64_GOTPC64)
```
leaq (%r11,%r15),%r15 # absolute address of the GOT
```
ForthemediummodeltheGOTpointerisdirectlyloaded,forthelargemodel
the absolute value of %rip is added to the relative offset to the base of the GOT
inordertoobtainitsabsoluteaddress(seefigure3.12).
### 3.5.4 Data Objects
This section describes only objects with static storage. Stack-resident objects are
excludedsinceprogramsalwayscomputetheirvirtualaddressrelativetothestack
```
orframepointers.
```
16If, at code generation-time, it is determined that either no other functions are called (leaf
functions), thecalledfunctionsaddressescanberesolvedandarewithin2GB,ornoglobaldata
objectsarereferredto,itisnotnecessarytostoretheGOTaddressin%r15andtheprologcode
thatinitializesitmaybeomitted.
35
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 37: Because only the movabs instruction uses 64-bit addresses directly, depend-

Because only the movabs instruction uses 64-bit addresses directly, depend-
ing on the code model either %rip-relative addressing or building addresses in
registersandaccessingthememorythroughtheregisterhastobeused.
Forabsoluteaddresses%rip-relativeencodingcanbeusedinthesmallmodel.
In the medium model the movabs instruction has to be used for accessing ad-
dresses.
Position-independendcodecannotcontainabsoluteaddress. Toaccessaglobal
symbol the address of the symbol has to be loaded from the Global Offset Table.
TheaddressoftheentryintheGOTcanbeobtainedwitha%rip-relativeinstruc-
tioninthesmallmodel.
36
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 38: Smallmodels

Smallmodels
Figure3.13: AbsoluteLoadandStore(SmallModel)
```
extern int src[65536]; .extern src
extern int dst[65536]; .extern dst
extern int *ptr; .extern ptr
static int lsrc[65536]; .local lsrc
.comm lsrc,262144,4
static int ldst[65536]; .local ldst
.comm ldst,262144,4
static int *lptr; .local lptr
.comm lptr,8,8
.text
```
dst[0] = src[0]; movl src(%rip), %eax
```
movl %eax, dst(%rip)
```
ptr = dst[0]; movq $dst, ptr(%rip)
*ptr = src[0]; movq ptr(%rip),%rax
```
movl src(%rip),%edx
movl %edx, (%rax)
```
ldst[0] = lsrc[0]; movl lsrc(%rip), %eax
```
movl %eax, ldst(%rip)
```
lptr = ldst; movq $dst, lptr(%rip)
*lptr = lsrc[0]; movq lptr(%rip),%rax
```
movl lsrc(%rip),%edx
movl %edx, (%rax)
```
37
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 39: Figure3.14: Position-IndependendLoadandStore(SmallPICModel)

Figure3.14: Position-IndependendLoadandStore(SmallPICModel)
```
extern int src[65536]; .extern src
extern int dst[65536]; .extern dst
extern int *ptr; .extern ptr
static int lsrc[65536]; .local lsrc
.comm lsrc,262144,4
static int ldst[65536]; .local ldst
.comm ldst,262144,4
static int *lptr; .local lptr
.comm lptr,8,8
.text
```
dst[0] = src[0]; movq src@GOTPCREL(%rip), %rax
```
movl (%rax), %edx
movq dst@GOTPCREL(%rip), %rax
movl %edx, (%rax)
```
ptr = dst; movq ptr@GOTPCREL(%rip), %rax
```
movq dst@GOTPCREL(%rip), %rdx
movq %rdx, (%rax)
```
*ptr = src[0]; movq ptr@GOTPCREL(%rip),%rax
```
movq (%rax), %rdx
movq src@GOTPCREL(%rip), %rax
movl (%rax), %eax
movl %eax, (%rdx)
```
ldst[0] = lsrc[0]; movl lsrc(%rip), %eax
```
movl %eax, ldst(%rip)
```
lptr = ldst; lea ldst(%rip),%rdx
```
movq %rdx, lptr(%rip)
```
*lptr = lsrc[0]; movq lptr(%rip),%rax
```
movl lsrc(%rip),%edx
movl %edx, (%rax)
```
38
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 40: Mediummodels

Mediummodels
Figure3.15: AbsoluteLoadandStore(MediumModel)
```
extern int src[65536]; .extern src
extern int dst[65536]; .extern dst
extern int *ptr; .extern ptr
static int lsrc[65536]; .local lsrc
.comm lsrc,262144,417
static int ldst[65536]; .local ldst
.comm ldst,262144,4
static int *lptr; .local lptr
.comm lptr,8,8
.text
```
dst[0] = src[0]; movabsl src, %eax
```
movabsl %eax, dst
```
ptr = dst; movabsq $dst,%rdx
```
movq %rdx, ptr
```
*ptr = src[0]; movq ptr(%rip),%rdx
```
movabsl src,%eax
movl %eax, (%rdx)
```
ldst[0] = lsrc[0]; movabsl lsrc, %eax
```
movabsl %eax, ldst
```
lptr = ldst; movabsq $ldst,%rdx
```
movabsq %rdx, lptr
```
*lptr = lsrc[0]; movq lptr(%rip),%rdx
```
movabsl lsrc,%eax
movl %eax, (%rdx)
```
39
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 41: Figure3.16: Position-IndependendLoadandStore(MediumPICModel)

Figure3.16: Position-IndependendLoadandStore(MediumPICModel)
```
extern int src[65536]; .extern src
extern int dst[65536]; .extern dst
extern int *ptr; .extern ptr
static int lsrc[65536]; .local lsrc
.comm lsrc,262144,4
static int ldst[65536]; .local ldst
.comm ldst,262144,4
static int *lptr; .local lptr
.comm lptr,8,8
.text
```
dst[0] = src[0]; movq src@GOTPCREL(%rip), %rax
```
movl (%rax), %edx
movq dst@GOTPCREL(%rip), %rax
movl %edx, (%rax)
```
ptr = dst; movq ptr@GOTPCREL(%rip), %rax
```
movq dst@GOTPCREL(%rip), %rdx
movq %rdx, (%rax)
```
*ptr = src[0]; movq ptr@GOTPCREL(%rip),%rax
```
movq (%rax), %rdx
movq src@GOTPCREL(%rip), %rax
movl (%rax), %eax
movl %eax, (%rdx)
```
40
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 42: Figure3.17: Position-IndependendLoadandStore(MediumPICModel),contin-

Figure3.17: Position-IndependendLoadandStore(MediumPICModel),contin-
ued
ldst[0] = lsrc[0]; movabsq lsrc@GOTOFF64, %rax
```
movl (%rax,%r15), %eax
movabsq ldst@GOTOFF64, %rdx
movl %eax, (%rdx,%r15)
```
lptr = ldst; movabsq ldst@GOTOFF64, %rax
```
addq %r15, %rax
movq %rax, lptr(%rip)
```
*lptr = lsrc[0]; movabsq lsrc@GOTOFF64, %rax
```
movl (%rax,%r15),%eax
movq lptr(%rip),%rdx
movl %eax, (%rdx)
```
LargeModels
Again, in order to access data at any position in the 64-bit addressing space, it is
necessarytocalculatetheaddressexplicitly18,notunlikethemediumcodemodel.
### 18 If, at code generation-time, it is determined that a referred to global data object address is
resolvedwithin2GB,the%rip-relativeaddressingmodecanbeusedinstead. Seeexample
infigure3.19.
41
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 43: Figure3.18: Absoluteglobaldataloadandstore

Figure3.18: Absoluteglobaldataloadandstore
```
static int src; Lsrc: .long
static int dst; Ldst: .long
extern int *ptr; .extern ptr
```
dst = src; movabs $Lsrc,%rax ; R_X86_64_64
```
movabs $Ldst,%rdx ; R_X86_64_64
movl (%rax),%ecx
movl %ecx,(%rdx)
```
ptr = &dst; movabs $ptr,%rax ; R_X86_64_64
```
movabs $Ldst,%rdx ; R_X86_64_64
movq %rdx,(%rax)
```
*ptr = src; movabs $Lsrc,%rax ; R_X86_64_64
```
movabs $ptr,%rdx ; R_X86_64_64
movl (%rax),%ecx
movq (%rdx),%rdx
movl %ecx,(%rdx)
```
Figure3.19: Fasterabsoluteglobaldataloadandstore
*ptr = src; movabs $ptr,%rdx ; R_X86_64_64
```
movl Lsrc(%rip),%ecx
movq (%rdx),%rdx
movl %ecx,(%rdx)
```
For position-independent code access to both static and external global data
assumes that the GOT address is stored in a dedicated register. In these examples
weassumeitisin%r1519 (seeFunctionPrologue):
19If, at code generation-time, it is determined that a referred to global data object address is
resolvedwithin2GB,the%rip-relativeaddressingmodecanbeusedinstead. Seeexample
infigure3.21.
42
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 44: Figure3.20: Position-independendglobaldataloadandstore

Figure3.20: Position-independendglobaldataloadandstore
```
static int src; Lsrc: .long
static int dst; Ldst: .long
extern int *ptr; .extern ptr
```
dst = src; movabs $Lsrc@GOTOFF,%rax ; R_X86_64_GOTOFF64
```
movabs $Ldst@GOTOFF,%rdx ; R_X86_64_GOTOFF64
movl (%rax,%r15),%ecx
movl %ecx,(%rdx,%r15)
```
ptr = &dst; movabs $ptr@GOT,%rax ; R_X86_64_GOT64
```
movabs $Ldst@GOTOFF,%rdx ; R_X86_64_GOTOFF64
movq (%rax,%r15),%rax
leaq (%rdx,%r15),%rcx
movq %rcx,(%rax)
```
*ptr = src; movabs $Lsrc@GOTOFF,%rax ; R_X86_64_GOTOFF64
```
movabs $ptr@GOT,%rdx ; R_X86_64_GOT64
movl (%rax,%r15),%ecx
movq (%rdx,%r15),%rdx
movl %ecx,(%rdx)
```
Figure3.21: Fasterposition-independendglobaldataloadandstore
*ptr = src; movabs $ptr@GOT,%rdx ; R_X86_64_GOT64
```
movl Lsrc(%rip),%ecx
movq (%rdx,%r15),%rdx
movl %ecx,(%rdx)
```
43
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 45: 3.5.5 Function Calls

### 3.5.5 Function Calls
SmallandModiumModels
**Figure 3.22: Position-Independent Direct Function Call (Small and Medium**
Model)
```
extern void function (); .globl function
```
function (); call function@PLT
Figure3.23: Position-IndependentIndirectFunctionCall
```
extern void (*ptr) (); .globl ptr, name
extern void name ();
```
ptr = name; movq ptr@GOTPCREL(%rip), %rax
```
movq name@GOTPCREL(%rip), %rdx
movq %rdx, (%rax)
```
(*ptr)(); movq ptr@GOTPCREL(%rip), %rax
```
call *(%rax)
```
Largemodels
It cannot be assumed that a function is within 2GB in general. Therefore, it is
necessary to explicitly calculate the desired address reaching the whole 64-bit
```
addressspace.
```
44
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 46: Figure3.24: Absolutedirectandindirectfunctioncall

Figure3.24: Absolutedirectandindirectfunctioncall
```
static void (*ptr) (void); Lptr: .quad
extern void foo (void); .globl foo
static void bar (void); Lbar: ...
```
foo (); movabs $foo,%r11 ; R_X86_64_64
```
call *%r11
```
bar (); movabs $Lbar,%r11 ; R_X86_64_64
```
call *%r11
```
ptr = foo; movabs $Lptr,%rax ; R_X86_64_64
```
movabs $foo,%r11 ; R_X86_64_64
movq %r11,(%rax)
```
ptr = bar; movabs $Lbar,%r11 ; R_X86_64_64
```
movq %r11,(%rax)
```
(*ptr) (); movabs $Lptr,%r11 ; R_X86_64_64
```
call *(%r11)
```
Andinthecaseofposition-independentobjects20:
Figure3.25: Position-independentdirectandindirectfunctioncall
```
static void (*ptr) (void); Lptr: .quad
extern void foo (void); .globl foo
static void bar (void); Lbar: ...
```
foo (); movabs $foo@GOT,%r11 ; R_x86_64_GOTPLT64
```
call *(%r11,%r15)
```
bar (); movabs $Lbar@GOTOFF,%r11 ; R_X86_64_GOTOFF64
```
leaq (%r11,%r15),%r11
call *%r11
```
ptr = foo; movabs $Lptr@GOTOFF,%rax ; R_X86_64_GOTOFF64
```
movabs $foo@PLTOFF,%r11 ; R_X86_64_PLTOFF64
leaq (%r11,%r15),%r11
movq %r11,(%rax,%r15)
```
ptr = bar; movabs $Lbar@GOTOFF,%r11 ; R_X86_64_GOTOFF64
```
leaq (%r11,%r15),%r11
movq %r11,(%rax,%r15)
```
(*ptr) (); movabs $Lptr@GOTOFF,%r11 ; R_X86_64_GOTOFF64
```
call *(%r11,%r15)
```
20Seesubsection“Implementationadvice”forsomeoptimizations.
45
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 47: Implementationadvice

Implementationadvice
If, at code generation-time, certain conditions are determined, it’s possible to
generate faster or smaller code sequences as the large model normally requires.
When:
(absolute)targetoffunctioncalliswithin2GB , a direct call or %rip-relative
```
addressingmightbeused:
```
bar (); call Lbar
ptr = bar; movabs $Lptr,%rax ; R_X86_64_64
```
leaq $Lbar(%rip),%r11
movq %r11,(%rax)
```
(PIC)thebaseofGOTiswithin2GB an indirect call to the GOT entry might
beimplementedlikeso:
foo (); call *(foo@GOT) ; R_X86_64_GOTPCREL
(PIC)thebaseofPLTiswithin2GB , the PLT entry may be referred to rela-
tivelyto%rip:
ptr = foo; movabs $Lptr@GOTOFF,%rax ; R_X86_64_GOTOFF64
```
leaq $foo@PLT(%rip),%r11 ; R_X86_64_PLT32
movq %r11,(%rax,%r15)
```
(PIC)targetoffunctioncalliswithin2GB andiseithernotglobalorboundlo-
```
cally, a direct call to the symbol may be used or it may be referred to rela-
```
tivelyto%rip:
bar (); call Lbar
ptr = bar; movabs $Lptr@GOTOFF,%rax ; R_X86_64_GOTOFF64
```
leaq $Lbar(%rip),%r11
movq %r11,(%rax,%r15)
```
3.5.6 Branching
SmallandMediumModels
As all labels are withing 2GB no special care has to be taken when implementing
branches. ThefullAMD64ISAisusable.
LargeModels
Because functions can be theoretically up to 16EB long, the maximum 32-bit
displacement of conditional and unconditional branches in the AMD64 ISA are
46
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 48: Figure3.27: Implicitcalculationoftargetaddress

Figure3.27: Implicitcalculationoftargetaddress
if (!a) testl %eax,%eax
{ jz 2f
```
... 1: ...
```
} 2:
goto Label; jmp Label
```
... ...
```
Label: Label:
not enough to address the branch target. Therefore, a branch target address is
calculatedexplicitly21. Forabsoluteobjects:
Figure3.26: Absolutebranchingcode
if (!a) testl %eax,%eax
{ jnz 1f
```
movabs $2f,%r11 ; R_X86_64_64
jmpq *%r11
... 1: ...
```
} 2:
goto Label; movabs $Label,%r11 ; R_X86_64_64
```
jmpq *%r11
... ...
```
Label: Label:
Forposition-independentobjects:
21If,atcodegeneration-time,itisdeterminedthatthetargetaddressesarewithin2GB,alterna-
tively,branchtargetaddressesmaybecalculatedimplicitly(seefigure3.27
47
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 49: Figure3.28: Position-independentbranchingcode

Figure3.28: Position-independentbranchingcode
if (!a) testl %eax,%eax
{ jnz 1f
```
movabs $2f@GOTOFF,%r11 ; R_X86_64_GOTOFF64
leaq (%r11,%r15),%r11
jmpq *%r11
```
1: ...
```
... 2:
```
}
goto Label; movabs $Label@GOTOFF,%r11 ; R_X86_64_GOTOFF64
```
leaq (%r11,%r15),%r11
jmpq *%r11
...
... Label:
```
Label:
Forabsoluteobjects,theimplementationoftheswitchstatementis:
Figure3.29: Absoluteswitchcode
switch (a) cmpl $0,%eax
{ jl .Ldefault
```
cmpl $2,%eax
```
jg .Ldefault
```
movabs $.Ltable,%r11 ; R_X86_64_64
jmpq *(%r11,%eax,8)
.section .lrodata,"aLM",@progbits,8
.align 8
.Ltable: .quad .Lcase0 ; R_X86_64_64
.quad .Ldefault ; R_X86_64_64
.quad .Lcase2 ; R_X86_64_64
.previous
```
default: .Ldefault:
```
... ...
```
case 0: .Lcase0:
```
... ...
```
case 2: .Lcase2:
```
... ...
```
}
When building position-independent objects, the switch statement imple-
mentationchangesto:
48
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 50: Figure3.30: Position-independentswitchcode

Figure3.30: Position-independentswitchcode
switch (a) cmpl $0,%eax
{ jl .Ldefault
```
cmpl $2,%eax
```
jg .Ldefault
```
movabs $.Ltable@GOTOFF,%r11 ; R_X86_64_GOTOFF64
leaq (%r11,%r15),%r11
movq *(%r11,%eax,8),%r11
leaq (%r11,%r15),%r11
jmpq *%r11
.section .lrodata,"aLM",@progbits,8
.align 8
.Ltable: .quad .Lcase0@GOTOFF ; R_X86_64_GOTOFF64
.quad .Ldefault@GOTOFF ; R_X86_64_GOTOFF64
.quad .Lcase2@GOTOFF ; R_X86_64_GOTOFF64
.previous
```
default: .Ldefault:
```
... ...
```
case 0: .Lcase0:
```
... ...
```
case 2: .Lcase2:
```
... ...
```
}
22
### 3.5.7 Variable Argument Lists
SomeotherwiseportableCprogramsdependontheargumentpassingscheme,im-
plicitly assuming that 1) all arguments are passed on the stack, and 2) arguments
appear in increasing order on the stack. Programs that make these assumptions
never have been portable, but they have worked on many implementations. How-
ever, they do not work on the AMD64 architecture because some arguments are
passed in registers. Portable C programs must use the header file <stdarg.h>
inordertohandlevariableargumentlists.
Whenafunctiontakingvariable-argumentsiscalled,%raxmustbesettothe
totalnumberoffloatingpointparameterspassedtothefunctioninSSEregisters.23
22Thejump-tableisemittedinadifferentsectionsoastooccupycachelineswithoutinstruction
bytes,thusavoidingexclusivecachesubsystemstothrash.
23This implies that the only legal values for %rax when calling a function with variable-
49
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 51: Figure3.31: ParameterPassingExamplewithVariable-ArgumentList

Figure3.31: ParameterPassingExamplewithVariable-ArgumentList
```
int a, b;
long double ld;
```
double m, n;
```
extern void func (int a, double m,...);
func (a, m, b, ld, n);
```
Figure3.32: RegisterAllocationExampleforVariable-ArgumentList
GeneralPurposeRegisters FloatingPointRegisters StackFrameOffset
```
%rdi: a %xmm0: m 0: ld
%rsi: b %xmm1: n
%rax: 2
```
TheRegisterSaveArea
The prologue of a function taking a variable argument list and known to call the
macro va_start is expected to save the argument registers to the register save
area. Eachargumentregisterhasafixedoffsetintheregistersaveareaasdefined
inthefigure3.33.
Only registers that might be used to pass arguments need to be saved. Other
registers are not accessed and can be used for other purposes. If a function is
known to never accept arguments passed in registers24, the register save area may
beomittedentirely.
Theprologueshoulduse%raxtoavoidunnecessarilysavingXMMregisters.
Thisisespeciallyimportantforintegeronlyprogramstopreventtheinitialization
oftheXMMunit.
argumentlistsare0to8(inclusive).
24Thisfactmaybedeterminedeitherbyexploringtypesusedbytheva_argmacro,orbythe
factthatthenamedargumentsalreadyareexhaustedtheargumentregistersentirely.
50
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 52: Figure3.33: RegisterSaveArea

Figure3.33: RegisterSaveArea
Register Offset
```
%rdi 0
%rsi 8
%rdx 16
%rcx 24
%r8 32
%r9 40
%xmm0 48
%xmm1 64
...
%xmm15 288
```
Theva_list Type
The va_list type is an array containing a single element of one structure con-
taining the necessary information to implement the va_arg macro. The C defi-
nitionofva_listtypeisgiveninfigure3.34.
Figure3.34: va_listTypeDeclaration
```
typedef struct {
unsigned int gp_offset;
unsigned int fp_offset;
void *overflow_arg_area;
void *reg_save_area;
```
} va_list[1];
Theva_start Macro
Theva_startmacroinitializesthestructureasfollows:
reg_save_area Theelementpointstothestartoftheregistersavearea.
51
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 53: overflow_arg_area This pointer is used to fetch arguments passed on the stack.

overflow_arg_area This pointer is used to fetch arguments passed on the stack.
It is initialized with the address of the first argument passed on the stack, if
any, and then always updated to point to the start of the next argument on
thestack.
gp_offset The element holds the offset in bytes from reg_save_area to the
place where the next available general purpose argument register is saved.
In case all argument registers have been exhausted, it is set to the value 48
(6∗8).
fp_offset The element holds the offset in bytes from reg_save_area to the
place where the next available floating point argument register is saved. In
case all argument registers have been exhausted, it is set to the value 304
(6∗8+16∗16).
Theva_arg Macro
Thealgorithmforthegenericva_arg(l, type)implementationisdefinedas
follows:
1. Determine whether type may be passed in the registers. If not go to step
7.
2. Compute num_gp to hold the number of general purpose registers needed
to pass type and num_fp to hold the number of floating point registers
needed.
3. Verifywhetherargumentsfitintoregisters. Inthecase:
l->gp_offset > 48−num_gp∗8
```
or
```
l->fp_offset > 304−num_fp∗16
gotostep7.
4. Fetchtypefroml->reg_save_areawithanoffsetofl->gp_offset
```
and/or l->fp_offset. This may require copying to a temporary loca-
```
tion in case the parameter is passed in different register classes or requires
an alignment greater than 8 for general purpose registers and 16 for XMM
registers.
52
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 54: 5. Set:

5. Set:
l->gp_offset = l->gp_offset+num_gp∗8
l->fp_offset = l->fp_offset+num_fp∗16.
6. Returnthefetchedtype.
7. Alignl->overflow_arg_areaupwardstoa16byteboundaryifalign-
mentneededbytypeexceeds8byteboundary.
8. Fetchtypefroml->overflow_arg_area.
9. Setl->overflow_arg_areato:
l->overflow_arg_area+sizeof(type)
10. Alignl->overflow_arg_areaupwardstoan8byteboundary.
11. Returnthefetchedtype.
The va_arg macro is usually implemented as a compiler builtin and ex-
panded in simplified forms for each particular type. Figure 3.35 is a sample im-
plementationoftheva_argmacro.
Figure3.35: SampleImplementationofva_arg(l, int)
```
movl l->gp_offset,%eax
cmpl $48,%eax Isregisteravailable?
```
jae stack Ifnot,usestack
```
leal $8(%rax),%edx Nextavailableregister
addq l->reg_save_area,%rax Addressofsavedregister
movl %edx,l->gp_offset Updategp_offset
jmp fetch
```
stack: movq l->overflow_arg_area,%rax Addressofstackslot
```
leaq 8(%rax),%rdx Nextavailablestackslot
movq %rdx,l->overflow_arg_area Update
```
fetch: movl (%rax),%eax Loadargument
53
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 55: 3.6 DWARF Definition

### 3.6 DWARF Definition
Thissection25 definestheDebugWithArbitraryRecordFormat(DWARF)debug-
ging format for the AMD64 processor family. The AMD64 ABI does not define
a debug format. However, all systems that do implement DWARF shall use the
followingdefinitions.
DWARF is a specification developed for symbolic, source-level debugging.
The debugging information format does not favor the design of any compiler or
debugger. For more information on DWARF, see DWARF Debugging Informa-
tionFormat,revision: Version2.0.0,July27,1993,UNIXInternational,Program
LanguagesSIG.
### 3.6.1 DWARF Release Number
The DWARF definition requires some machine-specific definitions. The register
number mapping needs to be specified for the AMD64 registers. In addition, the
DWARFVersion2specificationrequiresprocessor-specificaddressclasscodesto
bedefined.
### 3.6.2 DWARF Register Number Mapping
Table3.3626 outlinestheregisternumbermappingfortheAMD64processorfam-
ily.27
### 3.7 Stack Unwind Algorithm
The stack frames are not self descriptive and where stack unwinding is desirable
(such as for exception handling) additional unwind information needs to be gen-
erated. The information is stored in an allocatable section .eh_frame whose
format is identical to .debug_frame defined by the DWARF debug informa-
tion standard, see DWARF Debugging Information Format, with the following
extensions:
25ThissectionisstructuredinawaysimilartothePowerPCpsABI
26ThetabledefinesReturnAddresstohavearegisternumber,eventhoughtheaddressisstored
in0(%rsp)andnotinaphysicalregister.
27Thisdocumentdoesnotdefinemappingsforprivilegedregisters.
54
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 56: Figure3.36: DWARFRegisterNumberMapping

Figure3.36: DWARFRegisterNumberMapping
RegisterName Number Abbreviation
GeneralPurposeRegisterRAX 0 %rax
GeneralPurposeRegisterRDX 1 %rdx
GeneralPurposeRegisterRCX 2 %rcx
GeneralPurposeRegisterRBX 3 %rbx
GeneralPurposeRegisterRSI 4 %rsi
GeneralPurposeRegisterRDI 5 %rdi
FramePointerRegisterRBP 6 %rbp
StackPointerRegisterRSP 7 %rsp
ExtendedIntegerRegisters8-15 8-15 %r8–%r15
ReturnAddressRA 16
SSERegisters0–7 17-24 %xmm0–%xmm7
ExtendedSSERegisters8–15 25-32 %xmm8–%xmm15
FloatingPointRegisters0–7 33-40 %st0–%st7
MMXRegisters0–7 41-48 %mm0–%mm7
55
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 57: Positionindependence In order to avoid load time relocations for position inde-

Positionindependence In order to avoid load time relocations for position inde-
pendent code, the FDE CIE offset pointer should be stored relative to the
start of CIE table entry. Frames using this extension of the DWARF stan-
dardmustsettheCIEidentifiertagto1.
Outgoingargumentsareadelta To maintain the size of the temporarily allo-
cated outgoing arguments area present on the end of the stack (when us-
ing push instructions), operation GNU_ARGS_SIZE (0x2e) can be used.
This operation takes a single uleb128 argument specifying the current
size. This information is used to adjust the stack frame when jumping into
the exception handler of the function after unwinding the stack frame. Ad-
ditionally the CIE Augmentation shall contain an exact specification of the
encoding used. It is recommended to use a PC relative encoding whenever
possibleandadjustthesizeaccordingtothecodemodelused.
CIEAugmentations: The augmentation field is formated according to the aug-
mentationfieldformatingstringstoredintheCIEheader.
Thestringmaycontainthefollowingcharacters:
z Indicatesthatauleb128ispresentdeterminingthesizeoftheaugmen-
tationsection.
L Indicates the encoding (and thus presence) of an LSDA pointer in the
FDEaugmentation.
The data filed consist of single byte specifying the way pointers are
encoded. Itisamaskofthevaluesspecifiedbythetable3.37.
The default DWARF2 pointer encoding (direct 4-byte absolute point-
ers)isrepresentedbyvalue0.
R Indicates a non-default pointer encoding for FDE code pointers. The
formatingisrepresentedbyasinglebyteinthesamewayasinthe‘L’
command.
P Indicatesthepresenceandanencodingofalanguagepersonalityroutine
intheCIEaugmentation. Theencodingisrepresentedbyasinglebyte
in the same way as in the ’L’ command followed by a pointer to the
personalityfunctionencodedbythespecifiedencoding.
Whentheaugmentationispresent,thefirstcommandmustalwaysbe‘z’to
alloweasyskippingoftheinformation.
56
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 58: Figure3.37: Pointerencodingspecificationbyte

Figure3.37: Pointerencodingspecificationbyte
Mask Meaning
0x1 Valuesarestoredasuleb128orsleb128type(accordingtoflag0x8)
0x2 Valuesarestoredas2byteswideintegers(udata2orsdata2)
0x3 Valuesarestoredas4byteswideintegers(udata4orsdata2)
0x4 Valuesarestoredas8byteswideintegers(udata8orsdata2)
0x8 Valuesaresigned
0x10 ValuesarePCrelative
0x20 Valuesaretextsectionrelative
0x30 Valuesaredatasectionrelative
0x40 Valuesarerelativetothestartoffunction
In order to simplify manipulation of the unwind tables, the runtime library
provide higher level API to stack unwinding mechanism, for details see section
6.2.
57
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 59: Chapter 4

### Chapter 4
Object Files
### 4.1 ELF Header
### 4.1.1 Machine Information
For file identification in e_ident, the AMD64 architecture requires the follow-
ingvalues.
Table4.1: AMD64Identification
Position Value
e_ident[EI_CLASS] ELFCLASS64
e_ident[EI_DATA] ELFDATA2LSB
ProcessoridentificationresidesintheELFheader’se_machinememberand
musthavethevalueEM_X86_64.1
1Thevalueofthisidentifieris62.
58
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 60: 4.2 Sections

### 4.2 Sections
### 4.2.1 Section Flags
In order to allow linking object files of different code models, it is necessary to
provide for a way to differentiate those sections which may hold more than 2GB
from those which may not. This is accomplished by defining a processor-specific
sectionattributeflagforsh_flag(seetable4.2).
Table4.2: AMD64specificsectionheaderflag,sh_flags
Name Value
SHF_AMD64_LARGE 0x10000000
SHF_AMD64_LARGE If an object file section does not have this flag set, then it
may not hold more than 2GB and can be freely referred to in objects using
smallercodemodels. Otherwise,onlyobjectsusinglargercodemodelscan
refer to them. For example, a medium code model object can refer to data
in a section that sets this flag besides being able to refer to data in a section
that does not set it; likewise, a small code model object can refer only to
codeinasectionthatdoesnotsetthisflag.
### 4.2.2 Section types
Table4.3: Sectionheadertypes
sh_typename Value
SHT_X86_64_UNWIND 0x70000001
SHT_X86_64_UNWIND Thissectioncontainsunwindfunctiontableentriesfor
stack unwinding. The contents are described in Section 4.2.4 of this docu-
ment.
59
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 61: 4.2.3 Special sections

### 4.2.3 Special sections
Table4.4: Specialsections
Name Type Attributes
```
.got SHT_PROGBITS SHF_ALLOC+SHF_WRITE
.plt SHT_PROGBITS SHF_ALLOC+SHF_EXECINSTR
.eh_frame SHT_X86_64_UNWIND SHF_ALLOC
.got Thissectionholdstheglobaloffsettable.
.plt Thissectionholdstheprocedurelinkagetable.
.eh_frame This section holds the unwind function table. The contents are de-
```
scribedinSection4.2.4ofthisdocument.
The additional sections defined in table 4.5 are used by a system supporting
thelargecodemodel.
Table4.5: Additionalspecialsectionsforthelargecodemodel
Name Type Attributes
```
.lbss SHT_NOBITS SHF_ALLOC+SHF_WRITE+SHF_AMD64_LARGE
.ldata SHT_PROGBITS SHF_ALLOC+SHF_WRITE+SHF_AMD64_LARGE
.ldata1 SHT_PROGBITS SHF_ALLOC+SHF_WRITE+SHF_AMD64_LARGE
.lgot SHT_PROGBITS SHF_ALLOC+SHF_WRITE+SHF_AMD64_LARGE
.lplt SHT_PROGBITS SHF_ALLOC+SHF_EXECINSTR+SHF_AMD64_LARGE
.lrodata SHT_PROGBITS SHF_ALLOC+SHF_AMD64_LARGE
.lrodata1 SHT_PROGBITS SHF_ALLOC+SHF_AMD64_LARGE
.ltext SHT_PROGBITS SHF_ALLOC+SHF_EXECINSTR+SHF_AMD64_LARGE
```
In order to enable static linking of objects using different code models, the
followingsectionorderingissuggested:
60
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 62: .plt .init .fini .text .got .rodata .rodata1 .data .data1 .bss

```
.plt .init .fini .text .got .rodata .rodata1 .data .data1 .bss
```
Thesesectionscanhaveacombinedsizeofupto2GB.
```
.lplt .ltext .lgot .lrodata .lrodata1 .ldata .ldata1 .lbss
```
Thesesectionsplustheabovecanhaveacombinedsizeofupto16EB.
### 4.2.4 EH_FRAME sections
The call frame information needed for unwinding the stack is output in an ELF
section(s) of type SHT_AMD64_UNWIND. In the simplest case there will be one
such section per object file and it will be named .eh_frame. An .eh_frame
section consists of one or more subsections. Each subsection contains a CIE
(Common Information Entry) followed by varying number of FDEs (Frame De-
scriptor Entry). A FDE corresponds to an explicit or compiler generated function
in a compilation unit, all FDEs can access the CIE that begins their subsection
for data. If the code for a function is not one contiguous block, there will be a
separateFDEforeachcontiguoussub-piece.
If an object file contains C++ template instantiations there shall be a separate
CIEimmediatelyprecedingeachFDEcorrespondingtoaninstantiation.
Usingthepreferredencodingspecifiedbelow,the.eh_framesectioncanbe
entirelyresolvedatlinktimeandthuscanbecomepartofthetextsegment.
EH_PE encoding below refers to the pointer encoding as specified in the en-
hancedLSBChapter7forEh_Frame_Hdr.
61
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 63: Table4.6: CommonInformationEntry(CIE)

Table4.6: CommonInformationEntry(CIE)
Field Length(byte) Description
Length 4 Length of the CIE (not including this 4-
bytefield)
CIEid 4 Value 0 for .eh_frame (used to distin-
guish CIEs and FDEs when scanning the
section)
Version 1 ValueOne(1)
CIE Augmenta- string Null-terminated string with legal values
tionString being "" or ’z’ optionally followed by sin-
gle occurrances of ’P’, ’L’, or ’R’ in any
```
order. The presence of character(s) in the
```
string dictates the content of field 8, the
AugmentationSection. Eachcharacterhas
one or two associated operands in the AS
(see table 4.7 for which ones). Operand
```
orderdependsonpositioninthestring(’z’
```
mustbefirst).
Code Align Fac- uleb128 To be multiplied with the "Advance Lo-
tor cation" instructions in the Call Frame In-
```
structions
```
Data Align Fac- sleb128 TobemultipliedwithalloffsetsintheCall
tor FrameInstructions
RetAddressReg 1/uleb128 A "virtual" register representation of the
```
returnaddress. InDwarfV2,thisisabyte,
```
otherwise it is uleb128. It is a byte in gcc
3.3.x
Optional CIE varying Present if Augmentation String in Aug-
Augmentation mentationSectionfield4isnot0. Seetable
Section 4.7forthecontent.
Optional Call varying
Frame Instruc-
tions
62
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 64: Table4.7: CIEaugmentationsectioncontent

Table4.7: CIEaugmentationsectioncontent
Char Operands Length(byte) Description
z size uleb128 LengthoftheremainderoftheAugmen-
tationSection
P personality_enc 1 Encoding specifier - preferred value is a
pc-relative,signed4-byte
personality (encoded) Encoded pointer to personality routine
routine (actually to the PLT entry for the per-
sonalityroutine)
R code_enc 1 Non-default encoding for the
code-pointers (FDE members
initial_location and
```
address_range and the operand for
```
DW_CFA_set_loc) - preferred value
ispc-relative,signed4-byte
L lsda_enc 1 FDE augmentation bodies may contain
LSDA pointers. If so they are encoded
as specified here - preferred value is pc-
relative, signed 4-byte possibly indirect
thruaGOTentry
63
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 65: Table4.8: FrameDescriptorEntry(FDE)

Table4.8: FrameDescriptorEntry(FDE)
Field Length(byte) Description
Length 4 Length of the FDE (not including this 4-
bytefield)
CIEpointer 4 Distance from this field to the nearest pre-
ceding CIE (the value is subtracted from
the current address). This value can never
be zero and thus can be used to distin-
guish CIE’s and FDE’s when scanning the
```
.eh_framesection
```
InitialLocation var Referencetothefunctioncodecorrespond-
ing to this FDE. If ’R’ is missing from
the CIE Augmentation String, the field is
an 8-byte absolute pointer. Otherwise, the
correspondingEH_PEencodingintheCIE
Augmentation Section is used to interpret
thereference
AddressRange var Size ofthe functioncode correspondingto
this FDE. If ’R’ is missing from the CIE
AugmentationString,thefieldisan8-byte
unsigned number. Otherwise, the size is
determined by the corresponding EH_PE
encodingintheCIEAugmentationSection
(thevalueisalwaysabsolute)
Optional FDE var PresentifCIEAugmentationStringisnon-
Augmentation empty. Seetable4.9forthecontent.
Section
Optional Call var
Frame Instruc-
tions
64
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 66: Table4.9: FDEaugmentationsectioncontent

Table4.9: FDEaugmentationsectioncontent
Char Operands Length(byte) Description
z length uleb128 LengthoftheremainderoftheAugmen-
tationSection
L LSDA var LSDA pointer, encoded in the format
specified by the corresponding operand
in the CIE’s augmentation body. (only
presentiflength>0).
Theexistanceandsizeoftheoptionalcallframeinstructionareamustbecom-
putedbasedontheoverallsizeandtheoffsetreachedwhilescanningthepreceding
fieldsoftheCIEorFDE.
The overall size of a .eh_frame section is given in the ELF section header.
Theonlywaytodeterminethenumberofentriesistoscanthesectiontilltheend
```
andcount.
```
4.3 Symbol Table
Nochangesrequired.
### 4.4 Relocation
### 4.4.1 Relocation Types
TheAMD64ABIaddsoneadditionalfield:
65
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 67: Figure4.1: RelocatableFields

Figure4.1: RelocatableFields
### 7 word8 0
### 15 word16 0
### 31 word32 0
### 63 word64 0
word8 Thisspecifiesa8-bitfieldoccupying1byte.
word16 This specifies a 16-bit field occupying 2 bytes with arbitrary
byte alignment. These values use the same byte order as
otherwordvaluesintheAMD64architecture.
word32 This specifies a 32-bit field occupying 4 bytes with arbitrary
byte alignment. These values use the same byte order as
otherwordvaluesintheAMD64architecture.
word64 This specifies a 64-bit field occupying 8 bytes with arbitrary
byte alignment. These values use the same byte order as
otherwordvaluesintheAMD64architecture.
Thefollowingnotationsareusedforspecifyingrelocationsintable4.10:
A Representstheaddendusedtocomputethevalueoftherelocatablefield.
B Representsthebaseaddressatwhichasharedobjecthasbeenloadedintomem-
```
oryduringexecution. Generally,asharedobjectisbuiltwitha0basevirtual
address,buttheexecutionaddresswillbedifferent.
```
G Representstheoffsetintotheglobaloffsettableatwhichtherelocationentry’s
symbolwillresideduringexecution.
66
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 68: GOT Representstheaddressoftheglobaloffsettable.

GOT Representstheaddressoftheglobaloffsettable.
L Representstheplace(sectionoffsetoraddress)oftheProcedureLinkageTable
entryforasymbol.
P Represents the place (section offset or address) of the storage unit being relo-
cated(computedusingr_offset).
S Representsthevalueofthesymbolwhoseindexresidesintherelocationentry.
The AMD64 ABI architectures uses only Elf64_Rela relocation entries
withexplicitaddends. Ther_addendmemberservesastherelocationaddend.
67
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 69: Table4.10: RelocationTypes

Table4.10: RelocationTypes
Name Value Field Calculation
R_X86_64_NONE 0 none none
R_X86_64_64 1 word64 S + A
R_X86_64_PC32 2 word32 S + A - P
R_X86_64_GOT32 3 word32 G + A
R_X86_64_PLT32 4 word32 L + A - P
R_X86_64_COPY 5 none none
R_X86_64_GLOB_DAT 6 word64 S
R_X86_64_JUMP_SLOT 7 word64 S
R_X86_64_RELATIVE 8 word64 B + A
R_X86_64_GOTPCREL 9 word32 G + GOT + A - P
R_X86_64_32 10 word32 S + A
R_X86_64_32S 11 word32 S + A
R_X86_64_16 12 word16 S + A
R_X86_64_PC16 13 word16 S + A - P
R_X86_64_8 14 word8 S + A
R_X86_64_PC8 15 word8 S + A - P
R_X86_64_DPTMOD64 16 word64
R_X86_64_DTPOFF64 17 word64
R_X86_64_TPOFF64 18 word64
R_X86_64_TLSGD 19 word32
R_X86_64_TLSLD 20 word32
R_X86_64_DTPOFF32 21 word32
R_X86_64_GOTTPOFF 22 word32
R_X86_64_TPOFF32 23 word32
R_X86_64_PC64 24 word64 S + A - P
R_X86_64_GOTOFF64 25 word64 S + A - GOT
R_X86_64_GOTPC32 26 word32 GOT + A - P
The special semantics for most of these relocation types are identical to those
68
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 70: usedfortheIntel386ABI.2 3

usedfortheIntel386ABI.2 3
TheR_X86_64_GOTPCRELrelocationhasdifferentsemanticsfromtheR_X86_64_GOT32
```
orequivalenti386R_I386_GOTPCrelocation. Inparticular,becausetheAMD64
```
architecture has an addressing mode relative to the instruction pointer, it is possi-
ble to load an address from the GOT using a single instruction. The calculation
done by the R_X86_64_GOTPCREL relocation gives the difference between the
location in the GOT where the symbol’s address is given and the location where
therelocationisapplied.
The R_X86_64_32 and R_X86_64_32S relocations truncate the com-
puted value to 32-bits. The linker must verify that the generated value for the
R_X86_64_32(R_X86_64_32S)relocationzero-extends(sign-extends)tothe
```
original64-bitvalue.
```
A program or object file using R_X86_64_8, R_X86_64_16,
R_X86_64_PC16 or R_X86_64_PC8 relocations is not conformant to
this ABI, these relocations are only added for documentation purposes. The
R_X86_64_16, and R_X86_64_8 relocations truncate the computed value to
16-bitsresp. 8-bits.
The relocations R_X86_64_DPTMOD64, R_X86_64_DTPOFF64,
R_X86_64_TPOFF64 , R_X86_64_TLSGD , R_X86_64_TLSLD ,
R_X86_64_DTPOFF32, R_X86_64_GOTTPOFF and R_X86_64_TPOFF32
are listed for completeness. They are part of the Thread-Local Storage ABI
extensions and are documented in the document called “ELF Handling for
Thread-LocalStorage”4.
### 4.4.2 Large Models
In order to extend both the PLT and the GOT beyond 2GB, it is necessary to add
appropriaterelocationtypestohandlefull64-bitaddressing. Seefigure4.2.
2Even though the AMD64 architecture supports IP-relative addressing modes, a GOT is still
requiredsincetheoffsetfromaparticularinstructiontoaparticulardataitemcannotbeknownby
thestaticlinker.
3NotethattheAMD64architectureassumesthatoffsetsintoGOTare32-bitvalues,not64-bit
values. This choice means that a maximum of 232/8 = 229 entries can be placed in the GOT.
However,thatshouldbemorethanenoughformostprograms. Intheeventthatitisnotenough,
the linker could create multiple GOTs. Because 32-bit offsets are used, loads of global data do
```
notrequireloadingtheoffsetintoadisplacementregister;thebaseplusimmediatedisplacement
addressingformcanbeused.
```
4This document is currently available via http://people.redhat.com/drepper/
tls.pdf
69
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 71: Figure4.2: Largemodelrelocationtypes

Figure4.2: Largemodelrelocationtypes
Name Value Field Calculation
R_X86_64_GOT64 27 word64 G + A
R_X86_64_GOTPCREL64 28 word64 G + GOT - P + A
R_X86_64_GOTPC64 29 word64 GOT - P + A
R_X86_64_GOTPLT64 30 word64 G + A
R_X86_64_PLTOFF64 31 word64 L - GOT + A
70
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 72: Chapter 5

### Chapter 5
Program Loading and Dynamic
Linking
### 5.1 Program Loading
Program loading is a process of mapping file segments to virtual memory seg-
ments. For efficient mapping executable and shared object files must have seg-
ments whose file offsets and virtual addresses are congruent modulo the page
size.
To save space the file page holding the last page of the text segment may
alsocontainthefirstpageofthedatasegment. Thelastdatapagemaycontainfile
informationnotrelevanttotherunningprocess. Logically,thesystemenforcesthe
memory permissions as if each segment were complete and separate; segments’
```
addressesareadjustedtoensureeachlogicalpageintheaddressspacehasasingle
```
set of permissions. In the example above, the region of the file holding the end
of text and the beginning of data will be mapped twice: at one virtual address for
textandatadifferentvirtualaddressfordata.
The end of the data segment requires special handling for uninitialized data,
which the system defines to begin with zero values. Thus if a file’s last data page
includesinformationnotinthelogicalmemorypage,theextraneousdatamustbe
set to zero, not the unknown contents of the executable file. “Impurities” in the
other three pages are not logically part of the process image; whether the system
expungesthemisunspecified.
One aspect of segment loading differs between executable files and shared
objects. Executable file segments typically contain absolute code (see section 3.5
71
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 73: “Coding Examples”). To let the process execute correctly, the segments must

“Coding Examples”). To let the process execute correctly, the segments must
reside at the virtual addresses used to build the executable file. Thus the system
usesthep_vaddrvaluesunchangedasvirtualaddresses.
Ontheotherhand,sharedobjectsegmentstypicallycontainposition-independent
code. This lets a segments virtual address change from one process to another,
without invalidating execution behavior. Though the system chooses virtual ad-
dressesforindividualprocesses,itmaintainsthesegments’relativepositions. Be-
cause position-independent code uses relative addressing between segments, the
difference between virtual addresses in memory must match the difference be-
tweenvirtualaddressesinthefile.
### 5.1.1 Program header
ThefollowingAMD64programheadertypesaredefined:
Table5.1: Programheadertypes
Name Value
PT_GNU_EH_FRAME 0x6474e550
PT_SUNW_UNWIND 0x6474e550
PT_GNU_EH_FRAMEandPT_SUNW_UNWIND The segment contains the
stackunwindtables. SeeSection4.2.4ofthisdocument. 1
### 5.2 Dynamic Linking
DynamicSection
Dynamic section entries give information to the dynamic linker. Some of this
information is processor-specific, including the interpretation of some entries in
thedynamicstructure.
### 1 ThevaluefortheseprogramheadershavebeenplacedinthePT_LOOSandPT_HIOS(os
specificrange)inordertoadapttotheexistingGNUimplementation. NewOS’swantingtoagree
ontheseprogramheadershouldalsoadditintotheirOSspecificrange.
72
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 74: GlobalOffsetTable(GOT)

```
GlobalOffsetTable(GOT)
```
Position-independent code cannot, in general, contain absolute virtual addresses.
Global offset tables hold absolute addresses in private data, thus making the ad-
dresses available without compromising the position-independence and sharabil-
ityofaprogram’stext. Aprogramreferencesitsglobaloffsettableusingposition-
independent addressing and extracts absolute values, thus redirecting position-
independentreferencestoabsolutelocations.
If a program requires direct access to the absolute address of a symbol, that
symbolwillhaveaglobaloffsettableentry. Becausetheexecutablefileandshared
objects have separate global offset tables, a symbol’s address may appear in sev-
eral tables. The dynamic linker processes all the global offset table relocations
beforegivingcontroltoanycodeintheprocessimage,thusensuringtheabsolute
```
addressesareavailableduringexecution.
```
The tables first entry (number zero) is reserved to hold the address of the dy-
namic structure, referenced with the symbol _DYNAMIC. This allows a program,
such as the dynamic linker, to find its own dynamic structure without having yet
processed its relocation entries. This is especially important for the dynamic
linker, because it must initialize itself without relying on other programs to re-
locate its memory image. On the AMD64 architecture, entries one and two in the
globaloffsettablealsoarereserved.
Theglobaloffsettablecontains64-bitaddresses.
ForthelargemodelstheGOTisallowedtobeupto16EBinsize.
Figure5.1: GlobalOffsetTable
extern Elf64_Addr _GLOBAL_OFFSET_TABLE_ [];
The symbol _GLOBAL_OFFSET_TABLE_ may reside in the middle of the
```
.gotsection,allowingbothnegativeandnon-negative“subscripts”intothearray
```
ofaddresses.
FunctionAddresses
References to the address of a function from an executable file and the shared
objects associated with it might not resolve to the same value. References from
73
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 75: within shared objects will normally be resolved by the dynamic linker to the vir-

within shared objects will normally be resolved by the dynamic linker to the vir-
tual address of the function itself. References from within the executable file to
a function defined in a shared object will normally be resolved by the link editor
to the address of the procedure linkage table entry for that function within the
executablefile.
To allow comparisons of function addresses to work as expected, if an exe-
cutable file references a function defined in a shared object, the link editor will
place the address of the procedure linkage table entry for that function in its as-
sociated symbol table entry. This will result in symbol table entries with section
index of SHN_UNDEF but a type of STT_FUNC and a non-zero st_value. A
referencetotheaddressofafunctionfromwithinasharedlibrarywillbesatisfied
bysuchadefinitionintheexecutible.
Some relocations are associated with procedure linkage table entries. These
entries are used for direct function calls rather than for references to function
```
addresses. Theserelocationsdonotusethespecialsymbolvaluedescribedabove.
```
Otherwiseaverytightendlessloopwouldbecreated.
ProcedureLinkageTable
Muchastheglobaloffsettableredirectsposition-independentaddresscalculations
to absolute locations, the procedure linkage table redirects position-independent
functioncallstoabsolutelocations. Thelinkeditorcannotresolveexecutiontrans-
fers(suchasfunctioncalls)fromoneexecutableorsharedobjecttoanother. Con-
sequently, the link editor arranges to have the program transfer control to entries
intheprocedurelinkagetable. OntheAMD64architecture,procedurelinkageta-
bles reside in shared text, but they use addresses in the private global offset table.
The dynamic linker determines the destinations’ absolute addresses and modifies
the global offset table’s memory image accordingly. The dynamic linker thus can
redirect the entries without compromising the position-independence and share-
abilityoftheprogram’stext. Executablefilesandsharedobjectfileshaveseparate
procedurelinkagetables. UnlikeIntel386ABI,thisABIusesthesameprocedure
linkagetableforbothprogramsandsharedobjects(seefigure5.2).
74
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 76: Figure5.2: ProcedureLinkageTable(smallandmediummodels)

Figure5.2: ProcedureLinkageTable(smallandmediummodels)
```
.PLT0: pushq GOT+8(%rip) # GOT[1]
jmp *GOT+16(%rip) # GOT[2]
```
nop
nop
nop
nop
```
.PLT1: jmp *name1@GOTPCREL(%rip) # 16 bytes from .PLT0
pushq $index1
jmp .PLT0
.PLT2: jmp *name2@GOTPCREL(%rip) # 16 bytes from .PLT1
pushq $index2
jmp .PLT0
.PLT3: ...
```
Following the steps below, the dynamic linker and the program “cooperate”
toresolvesymbolicreferencesthroughtheprocedurelinkagetableandtheglobal
offsettable.
1. When first creating the memory image of the program, the dynamic linker
sets the second and the third entries in the global offset table to special
values. Stepsbelowexplainmoreaboutthesevalues.
2. Each shared object file in the process image has its own procedure linkage
table, and control transfers to a procedure linkage table entry only from
withinthesameobjectfile.
3. For illustration, assume the program calls name1, which transfers control
tothelabel.PLT1.
4. The first instruction jumps to the address in the global offset table entry for
name1. Initially the global offset table holds the address of the following
```
pushqinstruction,nottherealaddressofname1.
```
5. Nowtheprogrampushesarelocationindex(index)onthestack. Thereloca-
tionindexisa32-bit,non-negativeindexintotherelocationtableaddressed
by the DT_JMPREL dynamic section entry. The designated relocation en-
trywillhavetypeR_X86_64_JUMP_SLOT,anditsoffsetwillspecifythe
75
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 77: global offset table entry used in the previous jmp instruction. The reloca-

global offset table entry used in the previous jmp instruction. The reloca-
tion entry contains a symbol table index that will reference the appropriate
symbol,name1intheexample.
6. After pushing the relocation index, the program then jumps to .PLT0, the
firstentryintheprocedurelinkagetable. Thepushqinstructionplacesthe
valueofthesecondglobaloffsettableentry(GOT+8)onthestack,thusgiv-
ing the dynamic linker one word of identifying information. The program
then jumps to the address in the third global offset table entry (GOT+16),
whichtransferscontroltothedynamiclinker.
7. When the dynamic linker receives control, it unwinds the stack, looks at
the designated relocation entry, finds the symbol’s value, stores the “real”
```
address for name1 in its global offset table entry, and transfers control to
```
thedesireddestination.
8. Subsequent executions of the procedure linkage table entry will transfer
directly to name1, without calling the dynamic linker a second time. That
is,thejmpinstructionat.PLT1willtransfertoname1,insteadof“falling
through”tothepushqinstruction.
The LD_BIND_NOW environment variable can change the dynamic linking
behavior. If its value is non-null, the dynamic linker evaluates procedure linkage
tableentriesbeforetransferringcontroltotheprogram. Thatis,thedynamiclinker
processes relocation entries of type R_X86_64_JUMP_SLOT during process
initialization. Otherwise, the dynamic linker evaluates procedure linkage table
entries lazily, delaying symbol resolution and relocation until the first execution
ofatableentry.
LargeModels
In the small and medium code models the size of both the PLT and the GOT is
limited by the maximum 32-bit displacement size. Consequently, the base of the
PLTandthetopoftheGOTcanbeatmost2GBapart.
Therefore,inordertosupporttheavailableaddressingspaceof16EB,itisnec-
essary to extend both the PLT and the GOT. Moreover, the PLT needs to support
theGOTbeingover2GBawayandtheGOTcanbeover2GBinsize.2
2If it is determined that the base of the PLT is within 2GB of the top of the GOT, it is also
allowedtousethesamePLTlayoutforalargecodemodelobjectasthatofthesmallandmedium
codemodels.
76
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 78: ThePLTisextendedasshowninfigure5.3withtheassumptionthattheGOT

ThePLTisextendedasshowninfigure5.3withtheassumptionthattheGOT
```
addressisin%r153.
```
Figure5.3: FinallargecodemodelPLT
```
.PLT0: pushq 8(%r15) # GOT[1]
jmpq *16(%r15) # GOT[2]
```
rep
rep
rep
nop
rep
rep
rep
nop
```
.PLT1: movabs $name1@GOT,%r11 # 16 bytes from .PLT0
jmp *(%r11,%r15)
.PLT1a: pushq $index1 # "call" dynamic linker
jmp .PLT0
.PLT2: ... # 21 bytes from .PLT1
.PLTx: movabs $namex@GOT,%r11 # 102261125th entry
jmp *(%r11,%r15)
.PLTxa: pushq $indexx
pushq 8(%r15) # repeat .PLT0 code
jmpq *16(%r15)
.PLTy: ... # 27 bytes from .PLTx
```
Thisway,forthefirst102261125entries,eachPLTentrybesides.PLT0uses
only21bytes. Afterwards,thePLTentrycodechangesbyrepeatingthatof.PLT0,
wheneachPLTentryis27byteslong. Noticethatanyalignmentconsiderationis
droppedinordertokeepthePLTsizedown.
Each extended PLT entry is thus 5 to 11 bytes larger than the small and
mediumcodemodelPLTentries.
Thefunctionalityofentry.PLT0remainsunchangedfromthesmallandmedium
codemodels.
Notethatthesymbolindexisstilllimitedto32bits,whichwouldallowforup
to4Gglobalandexternalfunctions.
Typically, UNIX compilers support two types of PLT, generally through the
options -fpic and -fPIC. When building position-independent objects using
3SeeFunctionPrologue.
77
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 79: the large code model, only -fPIC is allowed. Using the option -fpic with the

the large code model, only -fPIC is allowed. Using the option -fpic with the
largecodemodelremainsreservedforfutureuse.
### 5.2.1 Program Interpreter
There is one valid program interpreter for programs conforming to the AMD64
ABI:
/lib/ld64.so.1
However,Linuxputsthisin
/lib64/ld-linux-x86-64.so.2
### 5.2.2 Initialization and Termination Functions
The implementation is responsible for executing the initialization functions spec-
ified by DT_INIT, DT_INIT_ARRAY, and DT_PREINIT_ARRAY entries in
the executable file and shared object files for a process, and the termination (or
finalization) functions specified by DT_FINI and DT_FINI_ARRAY, as speci-
fiedbytheSystemVABI.Theuserprogramplaysnofurtherpartinexecutingthe
initializationandterminationfunctionsspecifiedbythesedynamictags.
78
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 80: Chapter 6

### Chapter 6
Libraries
AfurtherreviewoftheIntel386ABIisneeded.
### 6.1 C Library
### 6.1.1 Global Data Symbols
Thesymbols_fp_hw,__flt_roundsand__huge_valarenotprovidedby
theAMD64ABI.
### 6.1.2 Floating Point Environment Functions
ISO C 99 defines the floating point environment functions from <fenv.h>.
Since AMD64 has two floating point units with separate control words, the pro-
gramming environment has to keep the control values in sync. On the other hand
thismeansthatroutinesaccessingthecontrolwordsonlyneedtoaccessoneunit,
```
and the SSE unit is the unit that should be accessed in these cases. The function
```
fegetround therefore only needs to report the rounding value of the SSE unit
```
andcanignorethex87unit.
```
79
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 81: 6.2 Unwind Library Interface

### 6.2 Unwind Library Interface
This section defines the Unwind Library interface 1, expected to be provided by
any AMD64 psABI-compliant system. This is the interface on which the C++
ABI exception-handling facilities are built. We assume as a basis the Call Frame
InformationtablesdescribedintheDWARFDebuggingInformationFormatdoc-
ument.
This section is meant to specify a language-independent interface that can be
usedtoprovidehigherlevelexception-handlingfacilitiessuchasthosedefinedby
C++.
Theunwindlibraryinterfaceconsistsofatleastthefollowingroutines:
_Unwind_RaiseException,
_Unwind_Resume,
_Unwind_DeleteException,
_Unwind_GetGR,
_Unwind_SetGR,
_Unwind_GetIP,
_Unwind_SetIP,
_Unwind_GetRegionStart,
_Unwind_GetLanguageSpecificData,
_Unwind_ForcedUnwind,
_Unwind_GetCFA
Inaddition,twodatatypesaredefined(_Unwind_Context and_Unwind_Exception
) to interface a calling runtime (such as the C++ runtime) and the above rou-
tine. Allroutinesandinterfacesbehaveasifdefinedextern "C". Inparticular,
the names are not mangled. All names defined as part of this interface have a
"_Unwind_"prefix.
Lastly, a language and vendor specific personality routine will be stored by
the compiler in the unwind descriptor for the stack frames requiring exception
processing. Thepersonalityroutineiscalledbytheunwindertohandlelanguage-
specifictaskssuchasidentifyingtheframehandlingaparticularexception.
1The overall structure and the external interface is derived from the IA-64 UNIX System V
ABI
80
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 82: 6.2.1 Exception Handler Framework

### 6.2.1 Exception Handler Framework
ReasonsforUnwinding
Therearetwomajorreasonsforunwindingthestack:
- exceptions,asdefinedbylanguagesthatsupportthem(suchasC++)
- “forced”unwinding(suchascausedbylongjmp orthreadtermination).
The interface described here tries to keep both similar. There is a major dif-
ference,however.
- In the case where an exception is thrown, the stack is unwound while the
exceptionpropagates,butitisexpectedthatthepersonalityroutineforeach
stackframeknowswhetheritwantstocatchtheexceptionorpassitthrough.
Thischoiceisthusdelegatedtothepersonalityroutine,whichisexpectedto
actproperlyforanytypeofexception,whether“native”or“foreign”. Some
guidelinesfor“actingproperly”aregivenbelow.
- During “forced unwinding”, on the other hand, an external agent is driving
the unwinding. For instance, this can be the longjmp routine. This exter-
nalagent,noteachpersonalityroutine,knowswhentostopunwinding. The
factthatapersonalityroutineisnotgivenachoiceaboutwhetherunwinding
willproceedisindicatedbythe_UA_FORCE_UNWIND flag.
Toaccommodatethesedifferences,twodifferentroutinesareproposed. _Unwind_RaiseException
performs exception-style unwinding, under control of the personality routines.
_Unwind_ForcedUnwind , on the other hand, performs unwinding, but gives
anexternalagenttheopportunitytointerceptcallstothepersonalityroutine. This
is done using a proxy personality routine, that intercepts calls to the personality
routine, letting the external agent override the defaults of the stack frame’s per-
sonalityroutine.
As a consequence, it is not necessary for each personality routine to know
aboutanyofthepossibleexternalagentsthatmaycauseanunwind. Forinstance,
the C++ personality routine need deal only with C++ exceptions (and possibly
disguising foreign exceptions), but it does not need to know anything specific
aboutunwindingdoneonbehalfoflongjmporpthreadscancellation.
81
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 83: TheUnwindProcess

TheUnwindProcess
ThestandardABIexceptionhandling/unwindprocessbeginswiththeraisingofan
exception, in one of the forms mentioned above. This call specifies an exception
objectandanexceptionclass.
Theruntimeframeworkthenstartsatwo-phaseprocess:
- In the search phase, the framework repeatedly calls the personality routine,
with the _UA_SEARCH_PHASE flag as described below, first for the cur-
rent %rip and register state, and then unwinding a frame to a new %rip
at each step, until the personality routine reports either success (a handler
foundinthequeriedframe)orfailure(nohandler)inallframes. Itdoesnot
actually restore the unwound state, and the personality routine must access
thestatethroughtheAPI.
- If the search phase reports a failure, e.g. because no handler was found, it
willcallterminate() ratherthancommencephase2.
If the search phase reports success, the framework restarts in the cleanup
phase. Again,itrepeatedlycallsthepersonalityroutine,withthe_UA_CLEANUP_PHASE
flag as described below, first for the current %rip and register state, and
then unwinding a frame to a new %rip at each step, until it gets to the
frame with an identified handler. At that point, it restores the register state,
```
andcontrolistransferredtotheuserlandingpadcode.
```
Each of these two phases uses both the unwind library and the personality
routines, since the validity of a given handler and the mechanism for transferring
control to it are language-dependent, but the method of locating and restoring
previousstackframesislanguage-independent.
A two-phase exception-handling model is not strictly necessary to implement
C++languagesemantics,butitdoesprovidesomebenefits. Forexample,thefirst
phase allows an exception-handling mechanism to dismiss an exception before
stack unwinding begins, which allows resumptive exception handling (correcting
theexceptionalconditionandresumingexecutionatthepointwhereitwasraised).
While C++ does not support resumptive exception handling, other languages do,
```
andthetwo-phasemodelallowsC++tocoexistwiththoselanguagesonthestack.
```
Notethatevenwithatwo-phasemodel,wemayexecuteeachofthetwophases
more than once for a single exception, as if the exception was being thrown more
thanonce. Forinstance,sinceitisnotpossibletodetermineifagivencatchclause
will rethrow or not without executing it, the exception propagation effectively
82
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 84: stops at each catch clause, and if it needs to restart, restarts at phase 1. This

stops at each catch clause, and if it needs to restart, restarts at phase 1. This
process is not needed for destructors (cleanup code), so the phase 1 can safely
process all destructor-only frames at once and stop at the next enclosing catch
clause.
For example, if the first two frames unwound contain only cleanup code, and
the third frame contains a C++ catch clause, the personality routine in phase 1,
does not indicate that it found a handler for the first two frames. It must do so for
the third frame, because it is unknown how the exception will propagate out of
thisthirdframe,e.g. byrethrowingtheexceptionorthrowinganewoneinC++.
The API specified by the AMD64 psABI for implementing this framework is
describedinthefollowingsections.
### 6.2.2 Data Structures
ReasonCodes
Theunwindinterfaceusesreasoncodesinseveralcontextstoidentifythereasons
forfailuresorotheractions,definedasfollows:
```
typedef enum {
```
_URC_NO_REASON = 0,
_URC_FOREIGN_EXCEPTION_CAUGHT = 1,
_URC_FATAL_PHASE2_ERROR = 2,
_URC_FATAL_PHASE1_ERROR = 3,
_URC_NORMAL_STOP = 4,
_URC_END_OF_STACK = 5,
_URC_HANDLER_FOUND = 6,
_URC_INSTALL_CONTEXT = 7,
_URC_CONTINUE_UNWIND = 8
} _Unwind_Reason_Code;
Theinterpretationsofthesecodesaredescribedbelow.
ExceptionHeader
The unwind interface uses a pointer to an exception header object as its repre-
sentation of an exception being thrown. In general, the full representation of an
exception object is language- and implementation-specific, but it will be prefixed
byaheaderunderstoodbytheunwindinterface,definedasfollows:
83
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 85: typedef void (*_Unwind_Exception_Cleanup_Fn)

```
typedef void (*_Unwind_Exception_Cleanup_Fn)
```
(_Unwind_Reason_Code reason,
```
struct _Unwind_Exception *exc);
struct _Unwind_Exception {
uint64 exception_class;
```
_Unwind_Exception_Cleanup_Fn exception_cleanup;
```
uint64 private_1;
uint64 private_2;
```
};
An _Unwind_Exception object must be eightbyte aligned. The first two
fields are set by user code prior to raising the exception, and the latter two should
neverbetouchedexceptbytheruntime.
The exception_class field is a language- and implementation-specific
identifier of the kind of exception. It allows a personality routine to distinguish
between native and foreign exceptions, for example. By convention, the high 4
bytes indicate the vendor (for instance AMD\0), and the low 4 bytes indicate the
language. For the C++ ABI described in this document, the low four bytes are
C++\0.
The exception_cleanup routine is called whenever an exception object
needs to be destroyed by a different runtime than the runtime which created the
exceptionobject,forinstanceifaJavaexceptioniscaughtbyaC++catchhandler.
Insuchacase,areasoncode(seeabove)indicateswhytheexceptionobjectneeds
tobedeleted:
_URC_FOREIGN_EXCEPTION_CAUGHT = 1 This indicates that a different
runtime caught this exception. Nested foreign exceptions, or rethrowing a
foreignexception,resultinundefinedbehavior.
_URC_FATAL_PHASE1_ERROR = 3 Thepersonalityroutineencounteredan
errorduringphase1,otherthanthespecificerrorcodesdefined.
_URC_FATAL_PHASE2_ERROR = 2 Thepersonalityroutineencounteredan
errorduringphase2,forinstanceastackcorruption.
Normally, all errors should be reported during phase 1 by returning from
_Unwind_RaiseException. However, landing pad code could cause stack
corruptionbetweenphase1andphase2. ForaC++exception,theruntimeshould
```
callterminate()inthatcase.
```
84
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 86: The private unwinder state (private_1 and private_2) in an exception

The private unwinder state (private_1 and private_2) in an exception
object should be neither read by nor written to by personality routines or other
parts of the language-specific runtime. It is used by the specific implementation
oftheunwinderonthehosttostoreinternalinformation,forinstancetoremember
thefinalhandlerframebetweenunwindingphases.
In addition to the above information, a typical runtime such as the C++ run-
time will add language-specific information used to process the exception. This
isexpectedtobeacontiguousareaofmemoryafterthe_Unwind_Exception
object, but this is not required as long as the matching personality routines know
howtodealwithit,andtheexception_cleanuproutinede-allocatesitprop-
erly.
UnwindContext
The _Unwind_Context type is an opaque type used to refer to a system-
specific data structure used by the system unwinder. This context is created and
destroyedbythesystem,andpassedtothepersonalityroutineduringunwinding.
```
struct _Unwind_Context
```
6.2.3 Throwing an Exception
_Unwind_RaiseException
_Unwind_Reason_Code _Unwind_RaiseException
```
( struct _Unwind_Exception *exception_object );
```
Raise an exception, passing along the given exception object, which should
have its exception_class and exception_cleanup fields set. The ex-
ception object has been allocated by the language-specific runtime, and has a
language-specificformat,exceptthatitmustcontainan_Unwind_Exception
```
struct (see Exception Header above). _Unwind_RaiseException does not
return, unless an error condition is found (such as no handler for the exception,
```
bad stack format, etc.). In such a case, an _Unwind_Reason_Code value is
```
returned.
```
Possibilitiesare:
_URC_END_OF_STACK Theunwinderencounteredtheendofthestackduring
phase1,withoutfindingahandler. Theunwindruntimewillnothavemodi-
85
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 87: fiedthestack. TheC++runtimewillnormallycalluncaught_exception()

fiedthestack. TheC++runtimewillnormallycalluncaught_exception()
inthiscase.
_URC_FATAL_PHASE1_ERROR Theunwinderencounteredanunexpecteder-
rorduringphase1,e.g. stackcorruption. Theunwindruntimewillnothave
modifiedthestack. TheC++runtimewillnormallycallterminate()in
thiscase.
If the unwinder encounters an unexpected error during phase 2, it should re-
turn _URC_FATAL_PHASE2_ERROR to its caller. In C++, this will usually be
__cxa_throw,whichwillcallterminate().
The unwind runtime will likely have modified the stack (e.g. popped frames
from it) or register context, or landing pad code may have corrupted them. As a
result,thethecallerof_Unwind_RaiseExceptioncanmakenoassumptions
aboutthestateofitsstackorregisters.
_Unwind_ForcedUnwind
```
typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)
```
(int version,
_Unwind_Action actions,
uint64 exceptionClass,
```
struct _Unwind_Exception *exceptionObject,
struct _Unwind_Context *context,
void *stop_parameter );
```
_Unwind_Reason_Code_Unwind_ForcedUnwind
( struct _Unwind_Exception *exception_object,
_Unwind_Stop_Fn stop,
```
void *stop_parameter );
```
Raise an exception for forced unwinding, passing along the given exception
object,whichshouldhaveitsexception_classandexception_cleanup
fields set. The exception object has been allocated by the language-specific run-
time,andhasalanguage-specificformat,exceptthatitmustcontainan_Unwind_Exception
```
struct(seeExceptionHeaderabove).
```
Forcedunwindingisasingle-phaseprocess(phase2ofthenormalexception-
handling process). The stop and stop_parameter parameters control the
termination of the unwind process, instead of the usual personality routine query.
The stop function parameter is called for each unwind frame, with the pa-
86
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 88: rameters described for the usual personality routine below, plus an additional

rameters described for the usual personality routine below, plus an additional
stop_parameter.
When the stop function identifies the destination frame, it transfers control
(according to its own, unspecified, conventions) to the user code as appropriate
without returning, normally after calling _Unwind_DeleteException. If
not,itshouldreturnan_Unwind_Reason_Codevalueasfollows:
_URC_NO_REASON Thisisnotthedestinationframe. Theunwindruntimewill
```
call the frame’s personality routine with the _UA_FORCE_UNWIND and
```
_UA_CLEANUP_PHASE flags set in actions, and then unwind to the next
frameandcallthestopfunctionagain.
_URC_END_OF_STACK Inordertoallow_Unwind_ForcedUnwindtoper-
form special processing when it reaches the end of the stack, the unwind
runtimewillcallitafterthelastframeisrejected,withaNULLstackpointer
inthecontext,andthestopfunctionmustcatchthiscondition(i.e. bynotic-
ing the NULL stack pointer). It may return this reason code if it cannot
handleend-of-stack.
_URC_FATAL_PHASE2_ERROR The stop function may return this code for
otherfatalconditions,e.g. stackcorruption.
If the stop function returns any reason code other than _URC_NO_REASON,
the stack state is indeterminate from the point of view of the caller of
_Unwind_ForcedUnwind. Rather than attempt to return, therefore, the un-
windlibraryshouldreturn_URC_FATAL_PHASE2_ERRORtoitscaller.
Example: longjmp_unwind()
The expected implementation of longjmp_unwind() is as follows. The
setjmp() routine will have saved the state to be restored in its custom-
ary place, including the frame pointer. The longjmp_unwind() routine
will call _Unwind_ForcedUnwind with a stop function that compares the
frame pointer in the context record with the saved frame pointer. If equal,
it will restore the setjmp() state as customary, and otherwise it will return
_URC_NO_REASONor_URC_END_OF_STACK.
Ifafuturerequirementfortwo-phaseforcedunwindingwereidentified,anal-
ternateroutinecouldbedefinedtorequestit,andanactionsparameterflagdefined
tosupportit.
87
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 89: _Unwind_Resume

_Unwind_Resume
void _Unwind_Resume
```
(struct _Unwind_Exception *exception_object);
```
Resumepropagationofanexistingexceptione.g. afterexecutingcleanupcode
in a partially unwound stack. A call to this routine is inserted at the end of a
landing pad that performed cleanup, but did not resume normal execution. It
causesunwindingtoproceedfurther.
_Unwind_Resume should not be used to implement rethrowing. To the un-
winding runtime, the catch code that rethrows was a handler, and the previous
unwindingsessionwasterminatedbeforeenteringit. Rethrowingisimplemented
bycalling_Unwind_RaiseExceptionagainwiththesameexceptionobject.
This is the only routine in the unwind library which is expected to be called
directly by generated code: it will be called at the end of a landing pad in a
"landing-pad"model.
### 6.2.4 Exception Object Management
_Unwind_DeleteException
void _Unwind_DeleteException
```
(struct _Unwind_Exception *exception_object);
```
Deletes the given exception object. If a given runtime resumes normal execu-
tion after catching a foreign exception, it will not know how to delete that excep-
tion. Suchanexceptionwillbedeletedbycalling_Unwind_DeleteException.
Thisisaconveniencefunctionthatcallsthefunctionpointedtobytheexception_cleanup
fieldoftheexceptionheader.
### 6.2.5 Context Management
These functions are used for communicating information about the unwind con-
text (i.e. the unwind descriptors and the user register state) between the unwind
libraryandthepersonalityroutineandlandingpad. Theyincluderoutinestoread
```
orsetthecontextrecordimagesofregistersinthestackframecorrespondingtoa
```
given unwind context, and to identify the location of the current unwind descrip-
torsandunwindframe.
88
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 90: _Unwind_GetGR

_Unwind_GetGR
uint64 _Unwind_GetGR
```
(struct _Unwind_Context *context, int index);
```
Thisfunctionreturnsthe64-bitvalueofthegivengeneralregister. Theregister
isidentifiedbyitsindexasgivenin3.36.
Duringthetwophasesofunwinding,noregistershaveaguaranteedvalue.
_Unwind_SetGR
void _Unwind_SetGR
(struct _Unwind_Context *context,
int index,
```
uint64 new_value);
```
This function sets the 64-bit value of the given register, identified by its index
asfor_Unwind_GetGR.
The behavior is guaranteed only if the function is called during phase 2 of
unwinding, and applied to an unwind context representing a handler frame, for
which the personality routine will return _URC_INSTALL_CONTEXT. In that
case, only registers %rdi, %rsi, %rdx, %rcx should be used. These scratch
registers are reserved for passing arguments between the personality routine and
thelandingpads.
_Unwind_GetIP
uint64 _Unwind_GetIP
```
(struct _Unwind_Context *context);
```
Thisfunctionreturnsthe64-bitvalueoftheinstructionpointer(IP).
Duringunwinding,thevalueisguaranteedtobetheaddressoftheinstruction
immediately following the call site in the function identified by the unwind con-
text. This value may be outside of the procedure fragment for a function call that
isknowntonotreturn(suchas_Unwind_Resume).
_Unwind_SetIP
void _Unwind_SetIP
(struct _Unwind_Context *context,
```
uint64 new_value);
```
Thisfunctionsetsthevalueoftheinstructionpointer(IP)fortheroutineiden-
tifiedbytheunwindcontext.
89
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 91: The behavior is guaranteed only when this function is called for an unwind

The behavior is guaranteed only when this function is called for an unwind
contextrepresentingahandlerframe,forwhichthepersonalityroutinewillreturn
_URC_INSTALL_CONTEXT.Inthiscase,controlwillbetransferredtothegiven
```
address,whichshouldbetheaddressofalandingpad.
```
_Unwind_GetLanguageSpecificData
uint64 _Unwind_GetLanguageSpecificData
```
(struct _Unwind_Context *context);
```
This routine returns the address of the language-specific data area for the cur-
rentstackframe.
Thisroutineisnotstrictlyrequired: itcouldbeaccessedthrough_Unwind_GetIP
using the documented format of the DWARF Call Frame Information Tables, but
sincethisworkhasbeendoneforfindingthepersonalityroutineinthefirstplace,
it makes sense to cache the result in the context. We could also pass it as an
argumenttothepersonalityroutine.
_Unwind_GetRegionStart
uint64 _Unwind_GetRegionStart
```
(struct _Unwind_Context *context);
```
This routine returns the address of the beginning of the procedure or code
fragmentdescribedbythecurrentunwinddescriptorblock.
Thisinformationisrequiredtoaccessanydatastoredrelativetothebeginning
of the procedure fragment. For instance, a call site table might be stored relative
to the beginning of the procedure fragment that contains the calls. During un-
winding, the function returns the start of the procedure fragment containing the
```
callsiteinthecurrentstackframe.
```
_Unwind_GetCFA
uint64 _Unwind_GetCFA
```
(struct _Unwind_Context *context);
```
This functionreturns the 64-bit CanonicalFrame Address whichis defined as
the value of %rsp at the call site in the previous frame. This value is guaranteed
to be correct any time the context has been passed to a personality routine or a
stopfunction.
90
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 92: 6.2.6 Personality Routine

### 6.2.6 Personality Routine
```
_Unwind_Reason_Code (*__personality_routine)
```
(int version,
_Unwind_Action actions,
uint64 exceptionClass,
```
struct _Unwind_Exception *exceptionObject,
struct _Unwind_Context *context);
```
The personality routine is the function in the C++ (or other language) run-
time library which serves as an interface between the system unwind library and
language-specificexceptionhandlingsemantics. Itisspecifictothecodefragment
described by an unwind info block, and it is always referenced via the pointer in
theunwindinfoblock,andhenceithasnopsABI-specifiedname.
Parameters
Thepersonalityroutineparametersareasfollows:
version Versionnumberoftheunwindingruntime,usedtodetectamis-match
betweentheunwinderconventionsandthepersonalityroutine,ortoprovide
backward compatibility. For the conventions described in this document,
versionwillbe1.
actions Indicates what processing the personality routine is expected to per-
form,asabitmask. Thepossibleactionsaredescribedbelow.
exceptionClass An 8-byte identifier specifying the type of the thrown ex-
ception. By convention, the high 4 bytes indicate the vendor (for instance
AMD\0), and the low 4 bytes indicate the language. For the C++ ABI
described in this document, the low four bytes are C++\0. This is not a
null-terminatedstring. Someimplementationsmayusenonullbytes.
exceptionObject Thepointertoamemorylocationrecordingthenecessary
information for processing the exception according to the semantics of a
givenlanguage(seetheExceptionHeadersectionabove).
context Unwinderstateinformationforusebythepersonalityroutine. Thisis
an opaque handle used by the personality routine in particular to access the
frame’sregisters(seetheUnwindContextsectionabove).
91
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 93: returnvalue Thereturnvaluefromthepersonalityroutineindicateshowfurther

```
returnvalue Thereturnvaluefromthepersonalityroutineindicateshowfurther
```
unwindshouldhappen,aswellaspossibleerrorconditions. Seethefollow-
ingsection.
PersonalityRoutineActions
TheactionsargumenttothepersonalityroutineisabitwiseORofoneormoreof
thefollowingconstants:
```
typedef int _Unwind_Action;
```
const _Unwind_Action _UA_SEARCH_PHASE = 1;
const _Unwind_Action _UA_CLEANUP_PHASE = 2;
const _Unwind_Action _UA_HANDLER_FRAME = 4;
const _Unwind_Action _UA_FORCE_UNWIND = 8;
_UA_SEARCH_PHASE Indicatesthatthepersonalityroutineshouldcheckifthe
currentframecontainsahandler,andifsoreturn_URC_HANDLER_FOUND,
```
or otherwise return _URC_CONTINUE_UNWIND. _UA_SEARCH_PHASE
```
cannotbesetatthesametimeas_UA_CLEANUP_PHASE.
_UA_CLEANUP_PHASE Indicates that the personality routine should perform
cleanup for the current frame. The personality routine can perform this
cleanupitself,bycallingnestedprocedures,andreturn_URC_CONTINUE_UNWIND.
Alternatively, it can setup the registers (including the IP) for transferring
controltoa"landingpad",andreturn_URC_INSTALL_CONTEXT.
_UA_HANDLER_FRAME During phase 2, indicates to the personality routine
that the current frame is the one which was flagged as the handler frame
during phase 1. The personality routine is not allowed to change its mind
betweenphase1andphase2,i.e. itmusthandletheexceptioninthisframe
inphase2.
_UA_FORCE_UNWIND During phase 2, indicates that no language is allowed
to "catch" the exception. This flag is set while unwinding the stack for
longjmporduringthreadcancellation. User-definedcodeinacatchclause
may still be executed, but the catch clause must resume unwinding with a
```
callto_Unwind_Resumewhenfinished.
```
92
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 94: TransferringControltoaLandingPad

TransferringControltoaLandingPad
If the personality routine determines that it should transfer control to a landing
pad (in phase 2), it may set up registers (including IP) with suitable values for
enteringthelandingpad(e.g. withlandingpadparameters),bycallingthecontext
managementroutinesabove. Itthenreturns_URC_INSTALL_CONTEXT.
Priortoexecutingcodeinthelandingpad,theunwindlibraryrestoresregisters
notalteredbythepersonalityroutine,usingthecontextrecord,totheirstateinthat
frame before the call that threw the exception, as follows. All registers specified
as callee-saved by the base ABI are restored, as well as scratch registers %rdi,
```
%rsi, %rdx, %rcx (see below). Except for those exceptions, scratch (or caller-
```
saved)registersarenotpreserved,andtheircontentsareundefinedontransfer.
The landing pad can either resume normal execution (as, for instance, at the
end of a C++ catch), or resume unwinding by calling _Unwind_Resume and
passingittheexceptionObjectargumentreceivedbythepersonalityroutine.
_Unwind_Resumewillneverreturn.
_Unwind_Resume should be called if and only if the personality routine
did not return _Unwind_HANDLER_FOUND during phase 1. As a result, the
unwinder can allocate resources (for instance memory) and keep track of them in
the exception object reserved words. It should then free these resources before
transferring control to the last (handler) landing pad. It does not need to free the
resources before entering non-handler landing-pads, since _Unwind_Resume
willultimatelybecalled.
The landing pad may receive arguments from the runtime, typically passed
inregisterssetusing_Unwind_SetGRbythepersonalityroutine. Foralanding
padthatcancallto_Unwind_Resume,oneargumentmustbetheexceptionObject
pointer,whichmustbepreservedtobepassedto_Unwind_Resume.
The landing pad may receive other arguments, for instance a switch value
indicating the type of the exception. Four scratch registers are reserved for this
use(%rdi,%rsi,%rdx,%rcx).
RulesforCorrectInter-LanguageOperation
The following rules must be observed for correct operation between languages
```
and/orruntimesfromdifferentvendors:
```
Anexceptionwhichhasanunknownclassmustnotbealteredbythepersonal-
ityroutine. Thesemanticsofforeignexceptionprocessingdependonthelanguage
ofthestackframebeingunwound. Thiscoversinparticularhowexceptionsfrom
93
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 95: aforeignlanguagearemappedtothenativelanguageinthatframe.

aforeignlanguagearemappedtothenativelanguageinthatframe.
If a runtime resumes normal execution, and the caught exception was created
by another runtime, it should call _Unwind_DeleteException. This is true
even if it understands the exception object format (such as would be the case
betweendifferentC++runtimes).
A runtime is not allowed to catch an exception if the _UA_FORCE_UNWIND
flagwaspassedtothepersonalityroutine.
Example: Foreign Exceptions in C++. In C++, foreign exceptions can be
caughtbyacatch(...) statement. Theycanalsobecaughtasiftheywereofa
__foreign_exceptionclass,definedin<exception>. The__foreign_exception
mayhavesubclasses,suchas__java_exceptionand__ada_exception,
iftheruntimeiscapableofidentifyingsomeoftheforeignlanguages.
Thebehaviorisundefinedinthefollowingcases:
- A __foreign_exception catch argument is accessed in any way (in-
cludingtakingitsaddress).
- A __foreign_exception is active at the same time as another excep-
tion(eitherthereisanestedexceptionwhilecatchingtheforeignexception,
```
ortheforeignexceptionwasitselfnested).
- uncaught_exception(),set_terminate(),set_unexpected(),
```
terminate(), or unexpected() is called at a time a foreign excep-
tion exists (for example, calling set_terminate() during unwinding
ofaforeignexception).
All these cases might involve accessing C++ specific content of the thrown
exception,forinstancetochainactiveexceptions.
Otherwise,acatchblockcatchingaforeignexceptionisallowed:
- to resume normal execution, thereby stopping propagation of the foreign
exceptionanddeletingit,or
- to rethrow the foreign exception. In that case, the original exception object
mustbeunalteredbytheC++runtime.
A catch-all block may be executed during forced unwinding. For instance, a
longjmpmayexecutecodeinacatch(...) duringstackunwinding. However,
94
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 96: if this happens, unwinding will proceed at the end of the catch-all block, whether

if this happens, unwinding will proceed at the end of the catch-all block, whether
```
ornotthereisanexplicitrethrow.
```
Settingthelow4bytesofexceptionclasstoC++\0isreservedforusebyC++
runtimescompatiblewiththecommonC++ABI.
### 6.3 Unwinding Through Assembler Code
For successful unwinding on AMD64 every function must provide a valid de-
bug information in the DWARF Debugging Information Format. In high level
languages (e.g. C/C++, Fortran, Ada, ...) this information is generated by the
compiler itself. However for hand-written assembly routines the debug info must
be provided by the author of the code. To ease this task some new assembler
directivesareadded:
```
.cfi_startproc is used at the beginning of each function that should have
```
an entry in .eh_frame . It initializes some internal data structures and
emitsarchitecturedependentinitialCFIinstructions. Each.cfi_startproc
directivehastobeclosedby.cfi_endproc.
```
.cfi_endproc isusedattheendofafunctionwhereitclosesitsunwinden-
```
trypreviouslyopenedby.cfi_startprocandemitsitto.eh_frame.
```
.cfi_def_cfa REGISTER, OFFSET defines a rule for computing CFA
```
as: takeaddressfromREGISTERandaddOFFSETtoit.
```
.cfi_def_cfa_register REGISTER modifiesaruleforcomputingCFA.
```
From now on REGISTER will be used instead of the old one. The offset
remainsthesame.
```
.cfi_def_cfa_offset OFFSET modifiesaruleforcomputingCFA.The
```
registerremainsthesame,butOFFSETisnew. Notethatthisistheabsolute
offsetthatwillbeaddedtoadefinedregistertocomputetheCFAaddress.
```
.cfi_adjust_cfa_offset OFFSET issimilarto.cfi_def_cfa_offset
```
but OFFSET is a relative value that is added or substracted from the previ-
ousoffset.
```
.cfi_offset REGISTER, OFFSET saves the previous value of REGIS-
```
TERatoffsetOFFSETfromCFA.
95
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 97: .cfi_rel_offset REGISTER, OFFSET savesthepreviousvalueofREG-

```
.cfi_rel_offset REGISTER, OFFSET savesthepreviousvalueofREG-
```
ISTERatoffsetOFFSETfromthecurrentCFAregister. Thisistransformed
to.cfi_offsetusingtheknowndisplacementoftheCFAregisterfrom
theCFA.Thisisofteneasiertouse,becausethenumberwillmatchthecode
itisannotating.
```
.cfi_escape EXPRESSION[, ...] allowstheusertoaddarbitrarybytes
```
to the unwind info. One might use this to add OS-specific CFI opcodes, or
genericCFIopcodesthattheassemblerdoesnotsupport.
96
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 98: Figure6.1: Examplesforunwindinginassembler

Figure6.1: Examplesforunwindinginassembler
# - function with local variable allocated on the stack
```
.type func_locvars,@function
```
func_locvars:
```
.cfi_startproc
```
# allocate space for local vars
```
sub $0x1234, %rsp
.cfi_adjust_cfa_offset 0x1234
```
# body
```
...
```
# release space of local vars and return
```
add $0x1234, %rsp
.cfi_adjust_cfa_offset -0x1234
ret
.cfi_endproc
```
# - function that moves frame pointer to another register
# and then allocates space for local variables
```
.type func_otherreg,@function
```
func_otherreg:
```
.cfi_startproc
```
# save frame pointer to r12
```
movq %rsp, %r12
.cfi_def_cfa_register r12
```
# allocate space for local vars
# (no .cfi_{def,adjust}_cfa_offset needed here,
# because CFA is computed from r12!)
```
sub $100,%rsp
```
# body
```
...
```
# restore frame pointer from r12
```
movq %r12, %rsp
.cfi_def_cfa_register rsp
ret
.cfi_endproc
```
97
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 99: Chapter 7

### Chapter 7
Development Environment
DuringcompilationofCorC++codeatleastthesymbolsintable7.1aredefined
bythepre-processor.
Table7.1: Predefinedpre-processorsymbols
__amd64
__amd64__
__x86_64
__x86_64__
98
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 100: Chapter 8

### Chapter 8
Execution Environment
Notdoneyet.
99
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 101: Chapter 9

### Chapter 9
Conventions
1
### 9.1 GOT pointer and IP relative addressing
A basic difference between the Intel386 ABI and the AMD64 ABI is the way
the GOT table is found. The Intel386 ABI, like (most) other processor specific
ABIs, uses a dedicated register (%ebx) to address the base of the GOT table.
The function prologue of every function needs to set up this register to the cor-
rect value. The AMD64 processor family introduces a new IP-relative addressing
modewhichisusedinthisABIinsteadofusingadedicatedregister.
OnAMD64theGOTtablecontains64-bitentries.
### 9.2 C++
For the C++ ABI we will use the IA-64 C++ ABI and instantiate it appropriately.
ThecurrentdraftofthatABIisavailableat:
http://www.codesourcery.com/cxx-abi/
1This chapter is used to document some features special to the AMD64 ABI. The different
sectionsmightbemovedtoanotherplaceorremovedcompletely.
100
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 102: 9.3 Fortran

### 9.3 Fortran
A formal Fortran ABI does not exist. Most Fortran compilers are designed for
very specific high performance computing applications, so Fortran compilers use
different passing conventions and memory layouts optimized for their specific
purpose. For example, Fortran applications that must run on distributed memory
machinesneedadifferentdatarepresentationforarraydescriptors(alsoknownas
dope vectors, or fat pointers) than applications running on symmetric multipro-
cessor shared memory machines. A normative ABI for Fortran is therefore not
desirable. However, for interoperability of different Fortran compilers, as well as
for interoperability with other languages, this section provides some some guide-
lines for data types representation, and argument passing. The guidelines in this
sectionarederivedfromtheGNUFortran77(G77)compiler. OtherFortrancom-
pilers already available for AMD64 at the time of this writing may use different
conventions,socompatibilityisnotguaranteed.
When this text uses the term Fortran function, the test applies to both Fortran
FUNCTIONandSUBROUTINEsubprogramsunlessspecificallystatedotherwise.
### 9.3.1 Representation of Fortran Types
For historical reasons, GNU Fortran 77 maps Fortran programs to the C ABI, so
thedatarepresentationcanbeexplainedbestbyprovidingthemappingofFortran
types to C types used by G77 on AMD642 as in figure 9.1. The “TYPE*N” no-
tationspecifies thatvariables oraggregate membersof typeTYPEshalloccupyN
bytesofstorage.
DataobjectswithaCHARACTERtypearerepresentedasanarrayofcharacters
of the C char type (not guaranteed to be “\0” terminated) with a separate length
counter to distinguish between between CHARACTER data objects with a length
parameter,andaggregatetypesofCHARACTERdataobjects,possiblyalsowitha
lengthparameter.
Layoutofotheraggregatetypesisimplementationdefined. GNUFortranputs
all arrays in contiguous memory in column-major order. GNU Fortran 95 builds
an equivalent C struct for derived types without reordering the type fields. Other
compilersmayuseotherrepresentationsasneeded. Therepresentationanduseof
Fortran90/95arraydescriptorsisimplementationdefined.
2G77providesaheaderg2c.hwiththeequivalentCtypedefinitionsforallsupportedFortran
scalartypes.
101
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 103: Figure9.1: MappingofFortrantoCtypes

Figure9.1: MappingofFortrantoCtypes
Fortran Datakind EquivalentCtype
INTEGER*4 Defaultinteger signed int
INTEGER*8 Doubleprecisioninteger signed long
REAL*4 SingleprecisionFPnumber float
REAL*8 DoubleprecisionFPnumber double
COMPLEX SingleprecisioncomplexFPnumber complex float
DOUBLE COMPLEX DoubleprecisioncomplexFPnumber complex double
LOGICAL Booleanlogicaltype signed char
CHARACTER Textstring char[] + length
Fortran 90/95 allow different kinds of each basic type using the kind type
parameterofatype. Kindtypeparametervaluesareimplementationdefined.
### 9.3.2 Argument Passing
For each given Fortran 77 function, an equivalent C prototype can be derived.
Once this equivalent C prototype is known, the C ABI conventions should be
appliedtodeterminehowargumentsarepassedtotheFortranfunction.
G77 passes all (user defined) formal arguments of a function by reference.
Specifically, pointers to the location in memory of a variable, array, array ele-
ment, a temporary location that holds the result of evaluating an expression or a
temporary or permanent location that holds the value of a constant (xf. g77 man-
ual)arepassedasactualarguments. Artificialcompilergeneratedargumentsmay
bepassedbyvalueorbyreference.
Data objects with a CHARACTER type are passed as a pointer to the charac-
ter string and its length, so that each CHARACTER formal argument in a Fortran
function results in two actual arguments in the equivalent C prototype. The first
argument occupies the position in the formal argument list of the Fortran func-
tion. This argument is a pointer to the array of characters that make up the string,
passed by the caller. The second argument is appended to the end of the user-
specifiedformalargumentlist. Thisargumentisofthedefaultintegertypeandits
value is the length of the array of characters, that is the length, passed as the first
argument. WhenmorethanoneCHARACTERargumentispresentinanargument
list,thelengthargumentsareappendedintheordertheoriginalargumentsappear.
Fortran90/95functionargumentswiththeINTENT(IN)attributeshouldalso
102
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 104: passed by value whenever possible. Fortran 90/95 passing of arrays is implemen-

passed by value whenever possible. Fortran 90/95 passing of arrays is implemen-
tationdefined.
103
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 105: Appendix A

Appendix A
Linux Conventions
This chapter describes some details that are only relevant to GNU/Linux systems
```
andtheLinuxkernel.
```
A.1 Execution of 32-bit Programs
The AMD64 processors are able to execute 64-bit AMD64 and also 32-bit ia32
programs. LibrariesconformingtotheIntel386ABIwillliveinthenormalplaces
like /lib, /usr/lib and /usr/bin. Libraries following the AMD64, will
uselib64subdirectoriesforthelibraries,e.g/lib64and/usr/lib64. Pro-
grams conforming to Intel386 ABI and to the AMD64 ABI will share directories
like/usr/bin. Inparticular,therewillbeno/bin64directory.
A.2 AMD64 Linux Kernel Conventions
Thesectionisinformativeonly.
A.2.1 Calling Conventions
The Linux AMD64 kernel uses internally the same calling conventions as user-
level applications (see section 3.2.3 for details). User-level applications that like
to call system calls should use the functions from the C library. The interface
betweentheClibraryandtheLinuxkernelisthesameasfortheuser-levelappli-
cationswiththefollowingdifferences:
104
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 106: 1. User-level applications use as integer registers for passing the sequence

1. User-level applications use as integer registers for passing the sequence
```
%rdi,%rsi,%rdx,%rcx,%r8and%r9. Thekernelinterfaceuses%rdi,
%rsi,%rdx,%r10,%r8and%r9.
```
2. A system-call is done via the syscall instruction. The kernel destroys
registers%rcxand%r11.
3. Thenumberofthesyscallhastobepassedinregister%rax.
4. System-callsarelimitedtosixarguments,noargumentispasseddirectlyon
thestack.
5. Returning from the syscall, register %rax contains the result of the
system-call. A value in the range between -4095 and -1 indicates an error,
itis-errno.
6. OnlyvaluesofclassINTEGERorclassMEMORYarepassedtothekernel.
A.2.2 Stack Layout
The Linux kernel does not honor the red zone (see 3.2.2 and therefore this area is
not allowed to be used by kernel code. Kernel code should be compiled by GCC
withtheoption-mno-red-zone.
A.2.3 Required Processor Features
Any program or kernel can expect that a AMD64 processor implements the fea-
tures mentioned in table A.1. In general a program has to check itself whether
thosefeaturesareavailablebutforAMD64systems,theseshouldalwaysbeavail-
able. Table˜reffeaturesusesthenamesfortheprocessorfeaturesasdocumentedin
theprocessormanual.
A.2.4 Miscelleaneous Remarks
Linux Kernel code is not allowed to change the x87 and SSE units. If those are
changedbykernelcode,theyhavetoberestoredproperlybeforesleepingorleav-
ingthekernel. Onpreemptivekernelsalsomoreprecautionsmaybeneeded.
105
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 107: FigureA.1: RequiredProcessorFeatures

FigureA.1: RequiredProcessorFeatures
Feature Comment
Featuresneedforprograms
fpu Necessaryforlong double,MMX
tsc User-visible
cx8 User-visible
```
cmov User-visible
```
mmx User-visible
sse User-visible,requiredforfloat
sse2 User-visible,requiredfordouble
fxsr RequiredforSSE/SSE2
syscall Forcallingthekernel
Featuresneedinthekernel
pae Thiskindofpagetablesisused
pse PAEneedsPSE.
msr Atleastneededtoenterlongmode
pge Kerneloptimization
pat Kerneloptimization
clflush Kerneloptimization
106
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 108: Index

Index
```
.cfi_adjust_cfa_offset,95 auxiliaryvector,29
.cfi_def_cfa,95
```
boolean,13
```
.cfi_def_cfa_offset,95
```
byte,11
```
.cfi_def_cfa_register,95
.cfi_endproc,95
```
C++,100
```
.cfi_escape,96
```
CallFrameInformationtables,80
```
.cfi_offset,95
```
codemodels,32
```
.cfi_rel_offset,96
.cfi_startproc,95 doublequadword,11
.eh_frame,95 doubleword,11
%rax,49 DT_FINI,78
```
_UA_CLEANUP_PHASE,82 DT_FINI_ARRAY,78
_UA_FORCE_UNWIND,81 DT_INIT,78
_UA_SEARCH_PHASE,82 DT_INIT_ARRAY,78
_Unwind_Context,80 DT_JMPREL,75
_Unwind_DeleteException,80 DT_PREINIT_ARRAY,78
_Unwind_Exception,80 DWARFDebuggingInformationFor-
_Unwind_ForcedUnwind,80,81 mat,80,95
_Unwind_GetCFA,80
eightbyte,11
_Unwind_GetGR,80
exceptions,23
_Unwind_GetIP,80
exec,28
_Unwind_GetLanguageSpecificData,
### 80 fegetround,79
_Unwind_GetRegionStart,80 fourbyte,11
_Unwind_RaiseException,80,
globaloffsettable,73,100
81
_Unwind_Resume,80
halfword,11
_Unwind_SetGR,80
_Unwind_SetIP,80 Kernelcodemodel,32
__float128,11
Largecodemodel,33
107
AMD64ABIDraft0.95–January24,2005–12:10


---

## Page 109: Largepositionindependentcodemodel,

Largepositionindependentcodemodel,
34
longjmp,81
Mediumcodemodel,32
Mediumpositionindependentcodemodel,
33
PIC,33,34
POD,18
ProcedureLinkageTable,67
procedurelinkagetable,74–76
programinterpreter,78
quardword,11
R_X86_64_JUMP_SLOT,75,76
redzone,16,105
registersavearea,50
signal,23
sixteenbyte,11
size_t,13
Smallcodemodel,32
Smallpositionindependentcodemodel,
33
terminate(),82
Thread-LocalStorage,69
twobyte,11
UnwindLibraryinterface,80
va_arg,52
va_list,51
va_start,51
word,11
108
AMD64ABIDraft0.95–January24,2005–12:10